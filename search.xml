<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pytorch 简单的介绍</title>
      <link href="2021/01/24/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
      <url>2021/01/24/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p><strong>本篇文章内容</strong>：</p><ol><li><code>Pytorch</code> 的四个常用的重要的模块</li><li><code>Pytorch</code> 中张量的基础知识</li></ol><a id="more"></a><p><img src="https://raw.githubusercontent.com/charypro/CloudImage/main/imgs/torch-workflow.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/charypro/CloudImage/main/imgs/torch-workflow.png" srcset="data:image/png;base64,666" alt="Torch Pipeline"></p><h2 id="Pytorch的主要模块"><a href="#Pytorch的主要模块" class="headerlink" title="Pytorch的主要模块"></a>Pytorch的主要模块</h2><p>Pytorch中最重要的四个模块：<strong>torch.nn</strong>，<strong>torch.optim</strong>，<strong>torch.utils.data</strong>，<strong>torch.autograd</strong></p><h3 id="torch-utils-data"><a href="#torch-utils-data" class="headerlink" title="torch.utils.data"></a><strong>torch.utils.data</strong></h3><p>此模块主要是数据加载，其中最重要的两个类：<strong>Dataset</strong> 和 <strong>DataLoader</strong></p><p><strong>Dataset</strong>：构建在Tensor数据类型之上，主要用于自定义数据集</p><p><strong>DataLoader</strong>：当您有一个大的数据集，并且希望从后台的数据集加载数据，以便它准备就绪并等待训练循环时使用</p><h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a><strong>torch.nn</strong></h3><p>用来创建神经网络模型，它提供了所有常用的神经网络层，如全连接层、卷积层、激活函数和损失函数等。</p><h3 id="torch-optim-、torch-autograd"><a href="#torch-optim-、torch-autograd" class="headerlink" title="torch.optim 、torch.autograd"></a><strong>torch.optim</strong> 、<strong>torch.autograd</strong></h3><p>创建好了网络模型结构，就准备好将数据提供给网络，然后就需要更新权重和偏差，让网络开始学习。</p><p><code>torch.optim</code>：是一个实现了各种优化算法的库</p><p><code>torch.autograd</code>：提供了类和函数用来对任意标量函数进行求导</p><h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><p>关于 <code>Tensor</code> 的构建、维度、类型、取值、与Numpy的互转和<code>Tensor</code>在CPU与GPU内的操作</p><details red><summary> 点一下我，查看代码 </summary>              <div class='content'>              <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1. Create</span></span><br><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a) <span class="comment"># tensor([1., 1., 1., 1., 1.])</span></span><br><span class="line">b = torch.zeros(<span class="number">5</span>)</span><br><span class="line">print(b) <span class="comment"># tensor([0., 0., 0., 0., 0.])</span></span><br><span class="line">c = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>])</span><br><span class="line">print(c) <span class="comment"># tensor([1., 2., 3., 4., 5.])</span></span><br><span class="line">d = torch.zeros(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">#tensor([[0., 0.],</span></span><br><span class="line"><span class="comment">#        [0., 0.],</span></span><br><span class="line"><span class="comment">#        [0., 0.]])</span></span><br><span class="line">e = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>],[<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># tensor([[1., 2.],</span></span><br><span class="line"><span class="comment">#        [3., 4.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D Tensor</span></span><br><span class="line">g = torch.tensor([[[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>]], [[<span class="number">5.</span>, <span class="number">6.</span>], [<span class="number">7.</span>, <span class="number">8.</span>]]])</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># tensor([[[1., 2.],</span></span><br><span class="line"><span class="comment">#         [3., 4.]],</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        [[5., 6.],</span></span><br><span class="line"><span class="comment">#         [7., 8.]]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. Shape</span></span><br><span class="line">print(e.shape)</span><br><span class="line"><span class="comment"># torch.Size([2, 2])</span></span><br><span class="line">print(g.shape)</span><br><span class="line"><span class="comment"># torch.Size([2, 2, 2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. Get</span></span><br><span class="line"><span class="comment"># Get element at index 2</span></span><br><span class="line">print(c[<span class="number">2</span>]) <span class="comment"># tensor(3.)</span></span><br><span class="line">print(e[<span class="number">1</span>][<span class="number">0</span>]) <span class="comment"># tensor(3.)</span></span><br><span class="line">print(g[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>])  <span class="comment"># tensor(5.)</span></span><br><span class="line">print(g[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) <span class="comment"># tensor(5.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># All elements</span></span><br><span class="line">print(e[:])</span><br><span class="line"><span class="comment"># All elements from index 1 to 2 (inclusive)</span></span><br><span class="line">print(c[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># All elements till index 4 (exclusive)</span></span><br><span class="line">print(c[:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># First row</span></span><br><span class="line">print(e[<span class="number">0</span>,:])</span><br><span class="line"><span class="comment"># Second column</span></span><br><span class="line">print(e[:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 4. Type</span></span><br><span class="line"><span class="comment"># type of elements</span></span><br><span class="line">int_tensor = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(int_tensor.dtype) <span class="comment"># torch.int64</span></span><br><span class="line"><span class="comment"># What if we changed any one element to floating point number?</span></span><br><span class="line">int_tensor = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4.</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(int_tensor.dtype) <span class="comment"># torch.float32</span></span><br><span class="line"><span class="comment"># This can be overridden as follows</span></span><br><span class="line">int_tensor = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4.</span>,<span class="number">5</span>,<span class="number">6</span>]], dtype=torch.int32)</span><br><span class="line">print(int_tensor.dtype) <span class="comment"># torch.int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 5. Tensor to/from NumPy Array</span></span><br><span class="line"><span class="comment"># Tensor to Array</span></span><br><span class="line">e = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>],[<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(e)</span><br><span class="line">e_numpy = e.numpy()</span><br><span class="line">print(e_numpy)</span><br><span class="line"><span class="comment"># array([[1., 2.],</span></span><br><span class="line"><span class="comment">#       [3., 4.]], dtype=float32)</span></span><br><span class="line"><span class="comment"># Array to Tensor</span></span><br><span class="line">h = np.array([[<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">h_tensor = torch.from_numpy(h)</span><br><span class="line">print(h_tensor)</span><br><span class="line"><span class="comment"># tensor([[8, 7, 6, 5],</span></span><br><span class="line"><span class="comment">#        [4, 3, 2, 1]] , dtype=torch.int32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. CPU v/s GPU Tensor</span></span><br><span class="line"><span class="comment"># Create a tensor for CPU</span></span><br><span class="line"><span class="comment"># This will occupy CPU RAM</span></span><br><span class="line">tensor_cpu = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>], [<span class="number">5.0</span>, <span class="number">6.0</span>]], device=<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="comment"># Create a tensor for GPU</span></span><br><span class="line"><span class="comment"># This will occupy GPU RAM</span></span><br><span class="line">tensor_gpu = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>], [<span class="number">5.0</span>, <span class="number">6.0</span>]], device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"><span class="comment"># Move GPU tensor to CPU</span></span><br><span class="line">tensor_gpu_cpu = tensor_gpu.to(device=<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="comment"># Move CPU tensor to GPU</span></span><br><span class="line">tensor_cpu_gpu = tensor_cpu.to(device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Deeplearning </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch进行图像分类(推理，使用预训练模型)</title>
      <link href="2020/12/28/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB(%E4%BB%85%E6%8E%A8%E7%90%86)/"/>
      <url>2020/12/28/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB(%E4%BB%85%E6%8E%A8%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<p><strong>本篇文章内容</strong>：</p><ol><li>使用<code>AlexNet</code>模型进行图像分类的流程</li><li>模型选取的五个标准</li><li>加载自定义模型</li></ol><a id="more"></a><h1 id="Pytorch图像分类-模型推理"><a href="#Pytorch图像分类-模型推理" class="headerlink" title="Pytorch图像分类 - 模型推理"></a>Pytorch图像分类 - 模型推理</h1><h2 id="使用-Torchvision-模块中的模型进行图像分类"><a href="#使用-Torchvision-模块中的模型进行图像分类" class="headerlink" title="使用 Torchvision 模块中的模型进行图像分类"></a>使用 <strong>Torchvision</strong> 模块中的模型进行图像分类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br></pre></td></tr></table></figure><p>使用 <code>dir(models)</code>可以查看 <code>torchvision</code>中支持哪些模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;AlexNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;DenseNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;GoogLeNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;GoogLeNetOutputs&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Inception3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;InceptionOutputs&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;MNASNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;MobileNetV2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ResNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ShuffleNetV2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SqueezeNet&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;VGG&#x27;</span>,</span><br><span class="line"> ...]</span><br></pre></td></tr></table></figure><h3 id="利用AlexNet进行图像分类"><a href="#利用AlexNet进行图像分类" class="headerlink" title="利用AlexNet进行图像分类"></a>利用<code>AlexNet</code>进行图像分类</h3><p><img src="https://raw.githubusercontent.com/charypro/CloudImage/main/imgs/AlexNet-1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/charypro/CloudImage/main/imgs/AlexNet-1.png" srcset="data:image/png;base64,666" alt="AlexNet Architecture"></p><h4 id="1-加载预训练模型"><a href="#1-加载预训练模型" class="headerlink" title="1: 加载预训练模型"></a><strong>1: 加载预训练模型</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alexnet = models.alexnet(pretrained=<span class="literal">True</span>)</span><br><span class="line">print(alexnet)</span><br></pre></td></tr></table></figure><details red><summary> 点击查看AlexNet的网络结构 </summary>              <div class='content'>              <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AlexNet(</span><br><span class="line">  (features): Sequential(</span><br><span class="line">    (0): Conv2d(3, 64, kernel_size&#x3D;(11, 11), stride&#x3D;(4, 4), padding&#x3D;(2, 2))</span><br><span class="line">    (1): ReLU(inplace&#x3D;True)</span><br><span class="line">    (2): MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (3): Conv2d(64, 192, kernel_size&#x3D;(5, 5), stride&#x3D;(1, 1), padding&#x3D;(2, 2))</span><br><span class="line">    (4): ReLU(inplace&#x3D;True)</span><br><span class="line">    (5): MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (6): Conv2d(192, 384, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (7): ReLU(inplace&#x3D;True)</span><br><span class="line">    (8): Conv2d(384, 256, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (9): ReLU(inplace&#x3D;True)</span><br><span class="line">    (10): Conv2d(256, 256, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (11): ReLU(inplace&#x3D;True)</span><br><span class="line">    (12): MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AdaptiveAvgPool2d(output_size&#x3D;(6, 6))</span><br><span class="line">  (classifier): Sequential(</span><br><span class="line">    (0): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">    (1): Linear(in_features&#x3D;9216, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">    (2): ReLU(inplace&#x3D;True)</span><br><span class="line">    (3): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">    (4): Linear(in_features&#x3D;4096, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">    (5): ReLU(inplace&#x3D;True)</span><br><span class="line">    (6): Linear(in_features&#x3D;4096, out_features&#x3D;1000, bias&#x3D;True)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="2-数据转换"><a href="#2-数据转换" class="headerlink" title="2: 数据转换"></a><strong>2: 数据转换</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">data_transforms = transforms.Compose([</span><br><span class="line">        transforms.resize(<span class="number">256</span>),</span><br><span class="line">        transforms.CenterCrop(<span class="number">224</span>),<span class="comment">#从中心开始裁剪</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                             [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])<span class="comment">#均值，标准差</span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3：加载输入图像并进行预处理"><a href="#3：加载输入图像并进行预处理" class="headerlink" title="3：加载输入图像并进行预处理"></a><strong>3：加载输入图像并进行预处理</strong></h4><p>对图像进行预处理，准备通过网络的图像的批次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;dog.jpg&quot;</span>)</span><br><span class="line">print(img)</span><br><span class="line"></span><br><span class="line">img_t = data_transforms(img)</span><br><span class="line">batch_t = torch.unsqueeze(img_t, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="4：模型推理"><a href="#4：模型推理" class="headerlink" title="4：模型推理"></a><strong>4：模型推理</strong></h4><ol><li><p>需要把模型放到评估模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alexnet.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure></li><li><p>进行推断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">out = alexnet(batch_t)</span><br><span class="line">print(out.shape) <span class="comment"># [1, 1000]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classes 是1000个类别的标签集合</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;imagenet_classes.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  classes = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()]</span><br><span class="line"><span class="comment"># 推断出该图片的类别，概率最大</span></span><br><span class="line">_, index = torch.<span class="built_in">max</span>(out, <span class="number">1</span>)</span><br><span class="line">percentage = torch.nn.functional.softmax(out, dim=<span class="number">1</span>)[<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">print(classes[index[<span class="number">0</span>]], percentage[index[<span class="number">0</span>]].item()) <span class="comment"># Labrador retriever 41.58518600463867</span></span><br><span class="line"><span class="comment"># 模型认为前五个最有可能属于的类别</span></span><br><span class="line">_, indices = torch.sort(out, descending=<span class="literal">True</span>)</span><br><span class="line">[(classes[idx], percentage[idx].item()) <span class="keyword">for</span> idx <span class="keyword">in</span> indices[<span class="number">0</span>][:<span class="number">5</span>]]</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-ResNet进行图像分类"><a href="#使用-ResNet进行图像分类" class="headerlink" title="使用 ResNet进行图像分类"></a>使用 <code>ResNet</code>进行图像分类</h3><p>同理，使用<code>resnet</code>模型操作和上述类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, load the model</span></span><br><span class="line">resnet = models.resnet101(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second, put the network in eval mode</span></span><br><span class="line">resnet.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third, carry out model inference</span></span><br><span class="line">out = resnet(batch_t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Forth, print the top 5 classes predicted by the model</span></span><br><span class="line">_, indices = torch.sort(out, descending=<span class="literal">True</span>)</span><br><span class="line">percentage = torch.nn.functional.softmax(out, dim=<span class="number">1</span>)[<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">[(labels[idx], percentage[idx].item()) <span class="keyword">for</span> idx <span class="keyword">in</span> indices[<span class="number">0</span>][:<span class="number">5</span>]] <span class="comment"># &#x27;Labrador retriever&#x27;, 48.25557327270508)</span></span><br></pre></td></tr></table></figure><h3 id="模型的选择标准"><a href="#模型的选择标准" class="headerlink" title="模型的选择标准"></a>模型的选择标准</h3><p>如何评估哪一个模型适合我们使用，遵循下面几个标准：</p><ol><li><strong>Top-1 Error</strong>：如果具有最高置信度的模型预测的类与真实类不同，则会出现<code>top-1</code>错误</li><li><strong>Top-5 Error</strong>：如果真实类不在模型预测的前5个类中（按置信度排序），则会出现<code>top-5</code>错误</li><li><strong>Inference Time on CPU</strong>：推理时间是模型推理步骤所用的时间</li><li><strong>Inference Time on GPU</strong></li><li><strong>Model size</strong>：这里size表示PyTorch提供的预训练模型的<code>.pth</code>文件所占用的物理空间</li></ol><h2 id="加载本地已存在的模型进行图像分类"><a href="#加载本地已存在的模型进行图像分类" class="headerlink" title="加载本地已存在的模型进行图像分类"></a>加载本地已存在的模型进行图像分类</h2><h4 id="加载本地的来自Torchvision-的网络模型"><a href="#加载本地的来自Torchvision-的网络模型" class="headerlink" title="加载本地的来自Torchvision 的网络模型"></a>加载本地的来自<strong>Torchvision</strong> 的网络模型</h4><p>不需要联网下载模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net = models.resnet101(pretrained=<span class="literal">False</span>) <span class="comment"># 这里为 False</span></span><br><span class="line">pthfile = <span class="string">r&#x27;E:\anaconda\app\envs\luo\Lib\site-packages\torchvision\models\squeezenet1_1.pth&#x27;</span></span><br><span class="line">net.load_state_dict(torch.load(pthfile))</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><h4 id="加载自定义的模型"><a href="#加载自定义的模型" class="headerlink" title="加载自定义的模型"></a>加载自定义的模型</h4><p>第一种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##首先保存模型到checkpoint.pth</span></span><br><span class="line">torch.save(resnet50.state_dict(), ‘ckp/model.pth’)</span><br><span class="line"></span><br><span class="line"><span class="comment">##然后加载预训练的模型</span></span><br><span class="line">resnet=resnet50(pretrained=<span class="literal">False</span>)</span><br><span class="line">resnet.load_state_dict(torch.load(<span class="string">&#x27;ckp/model.pth&#x27;</span>))</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.save (model, PATH) <span class="comment"># 保存</span></span><br><span class="line">model = torch.load(PATH) <span class="comment"># 恢复</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/deeposcar/article/details/103872195">Pytorch 加载自己的训练模型</a></p>]]></content>
      
      
      <categories>
          
          <category> Deeplearning </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch进行图像分割</title>
      <link href="2020/12/28/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2(%E4%BB%85%E6%8E%A8%E7%90%86)/"/>
      <url>2020/12/28/%E5%BC%80%E5%8F%91/AI/Pytorch%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2(%E4%BB%85%E6%8E%A8%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<p><strong>本篇文章内容</strong>：</p><ol><li>一个简单的图像分类例子</li></ol><a id="more"></a><h2 id="数据和模型"><a href="#数据和模型" class="headerlink" title="数据和模型"></a>数据和模型</h2><p>模型期望使用 Imagenet 均值和标准差对3通道图像（RGB）进行归一化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean &#x3D; [0.485, 0.456, 0.406], std &#x3D; [0.229, 0.224, 0.225]</span><br></pre></td></tr></table></figure><p>模型输入数据的结构：<code>[Ni x Ci x Hi x Wi]</code></p><ul><li>Ni : 批大小</li><li>Ci : 通道数（3）</li><li>Hi : 图像的高度</li><li>Wi : 图像的宽度</li></ul><p>模型输出数据的结构：<code>[No x Co x Ho x Wo]</code></p><ul><li>No : 是批量大小（与相同Ni）</li><li>Co : 是数据集具有的类数！</li><li>Ho : 图片的高度（Hi几乎与大多数情况相同）</li><li>Wo : 图片的宽度（Wi几乎与所有情况相同）</li></ul><p><code>torchvision</code> 模型输出的是一个<code>OrderedDict</code>而不是<code>torch.Tensor</code>。在eval()模式，输出是一个<code>OrderedDict</code>只有一个键 <code>out</code>。此<code>out</code>键保存输出，并且对应的值为<code>[No x Co x Ho x Wo]</code>。</p><h2 id="使用Resnet-101作为主干的FCN模型"><a href="#使用Resnet-101作为主干的FCN模型" class="headerlink" title="使用Resnet-101作为主干的FCN模型"></a>使用<code>Resnet-101</code>作为主干的<code>FCN</code>模型</h2><h3 id="载入预先训练的模型"><a href="#载入预先训练的模型" class="headerlink" title="载入预先训练的模型"></a>载入预先训练的模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># pretrained=True标志如果模型尚未出现在缓存中，将下载该模型。.eval()会加载模型</span></span><br><span class="line">fcn = models.segmentation.fcn_resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>() </span><br></pre></td></tr></table></figure><h3 id="预处理图像"><a href="#预处理图像" class="headerlink" title="预处理图像"></a>预处理图像</h3><p>预处理步骤：</p><ol><li>调整图像大小 (256 x 256)</li><li>中心裁剪到 (224 x 224)</li><li>将其转换为Tensor –图像中的所有值都会缩放，使其位于中间范围[0, 1]而不是原始[0, 255]范围内。</li><li>使用Imagenet特定值对其进行规范化，其中 mean = [0.485, 0.456, 0.406], std = [0.229, 0.224, 0.225]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line">trf = T.Compose([<span class="comment"># 这里我们定义一个变量变换，它是对输入图像进行的所有图像变换的组合</span></span><br><span class="line"> T.Resize(<span class="number">256</span>), <span class="comment"># 将图像调整为256×256像素</span></span><br><span class="line">                 T.CenterCrop(<span class="number">224</span>),<span class="comment"># 将图像裁剪为围绕中心的224×224像素</span></span><br><span class="line">                 T.ToTensor(), <span class="comment"># 将图像转换为PyTorch Tensor数据类型</span></span><br><span class="line">                 T.Normalize(mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],  <span class="comment"># 通过将图像的均值和标准差设置为指定值来对图像进行归一化</span></span><br><span class="line">                             std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br></pre></td></tr></table></figure><h3 id="加载输入图像并进行预处理"><a href="#加载输入图像并进行预处理" class="headerlink" title="加载输入图像并进行预处理"></a>加载输入图像并进行预处理</h3>需要<code>unsqueeze</code>图像尺寸，使之从<code>[C x H x W]</code>成为<code>[1 x C x H x W]</code>,这是必需的，因为我们需要一个批次通过网络传递进行批处理。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;D:/imagedatas/bird.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.imshow(img); plt.show()</span></span><br><span class="line">inp = trf(img).unsqueeze(<span class="number">0</span>) <span class="comment"># 对图像进行预处理并准备要通过网络传递的批次</span></span><br></pre></td></tr></table></figure><h3 id="模型推断"><a href="#模型推断" class="headerlink" title="模型推断"></a>模型推断</h3>将图片通过网络得到一个<code>out</code>输出<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">out = fcn(inp)[<span class="string">&#x27;out&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span> (out.shape) <span class="comment"># torch.Size([1, 21, 224, 224])</span></span><br><span class="line"><span class="comment"># 该模型训练了21个类，输出有21通道，输出转换为2D图像或1通道图像，其中该图像的每个像素对应一个类。</span></span><br><span class="line"><span class="comment"># 2D图像中的每个(x，y)像素对应表示类的0到20之间的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代表类的每个像素位置取一个最大索引</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">om = torch.argmax(out.squeeze(), dim=<span class="number">0</span>).detach().cpu().numpy()</span><br><span class="line"><span class="built_in">print</span> (om.shape)</span><br><span class="line"><span class="built_in">print</span> (np.unique(om))</span><br></pre></td></tr></table></figure></li></ol><h2 id="为图像上色-完整代码"><a href="#为图像上色-完整代码" class="headerlink" title="为图像上色(完整代码)"></a>为图像上色(完整代码)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the helper function 为一张图片上的不同的类别(像素坐标)上色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_segmap</span>(<span class="params">image, nc=<span class="number">21</span></span>):</span></span><br><span class="line">  </span><br><span class="line">  label_colors = np.array([(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),  <span class="comment"># 0=background</span></span><br><span class="line">               <span class="comment"># 1=aeroplane, 2=bicycle, 3=bird, 4=boat, 5=bottle</span></span><br><span class="line">               (<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>), (<span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>), (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>),</span><br><span class="line">               <span class="comment"># 6=bus, 7=car, 8=cat, 9=chair, 10=cow</span></span><br><span class="line">               (<span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>), (<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>), (<span class="number">64</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">192</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">64</span>, <span class="number">128</span>, <span class="number">0</span>),</span><br><span class="line">               <span class="comment"># 11=dining table, 12=dog, 13=horse, 14=motorbike, 15=person</span></span><br><span class="line">               (<span class="number">192</span>, <span class="number">128</span>, <span class="number">0</span>), (<span class="number">64</span>, <span class="number">0</span>, <span class="number">128</span>), (<span class="number">192</span>, <span class="number">0</span>, <span class="number">128</span>), (<span class="number">64</span>, <span class="number">128</span>, <span class="number">128</span>), (<span class="number">192</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">               <span class="comment"># 16=potted plant, 17=sheep, 18=sofa, 19=train, 20=tv/monitor</span></span><br><span class="line">               (<span class="number">0</span>, <span class="number">64</span>, <span class="number">0</span>), (<span class="number">128</span>, <span class="number">64</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">192</span>, <span class="number">0</span>), (<span class="number">128</span>, <span class="number">192</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">64</span>, <span class="number">128</span>)])</span><br><span class="line"></span><br><span class="line">  r = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">  g = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">  b = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nc):</span><br><span class="line">    idx = image == l</span><br><span class="line">    r[idx] = label_colors[l, <span class="number">0</span>]</span><br><span class="line">    g[idx] = label_colors[l, <span class="number">1</span>]</span><br><span class="line">    b[idx] = label_colors[l, <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">  rgb = np.stack([r, g, b], axis=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> rgb</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">segment</span>(<span class="params">net, path, show_orig=<span class="literal">True</span>, dev=<span class="string">&#x27;cuda&#x27;</span></span>):</span></span><br><span class="line">  img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">  <span class="keyword">if</span> show_orig: plt.imshow(img); plt.axis(<span class="string">&#x27;off&#x27;</span>); plt.show()</span><br><span class="line">  <span class="comment"># Comment the Resize and CenterCrop for better inference results</span></span><br><span class="line">  trf = T.Compose([T.Resize(<span class="number">640</span>), </span><br><span class="line">                   <span class="comment">#T.CenterCrop(224), </span></span><br><span class="line">                   T.ToTensor(), </span><br><span class="line">                   T.Normalize(mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                               std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br><span class="line">  inp = trf(img).unsqueeze(<span class="number">0</span>).to(dev)</span><br><span class="line">  out = net.to(dev)(inp)[<span class="string">&#x27;out&#x27;</span>]</span><br><span class="line">  om = torch.argmax(out.squeeze(), dim=<span class="number">0</span>).detach().cpu().numpy()</span><br><span class="line">  rgb = decode_segmap(om)</span><br><span class="line">  plt.imshow(rgb); plt.axis(<span class="string">&#x27;off&#x27;</span>); plt.show()</span><br><span class="line"></span><br><span class="line">segment(fcn, <span class="string">&#x27;./horse.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用DeepLab模型"><a href="#使用DeepLab模型" class="headerlink" title="使用DeepLab模型"></a>使用<code>DeepLab</code>模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlab = models.segmentation.deeplabv3_resnet101(pretrained=<span class="number">1</span>).<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><p>其他操作与上面类似。</p>]]></content>
      
      
      <categories>
          
          <category> Deeplearning </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下常见问题解决方法</title>
      <link href="2020/12/06/%E5%BC%80%E5%8F%91/Linux/Linux%E4%B8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2020/12/06/%E5%BC%80%E5%8F%91/Linux/Linux%E4%B8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Linux下常见问题和解决方法</p><a id="more"></a><ol><li>安装完<code>OpenCV</code>后，使用命令行编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ rgbtogray.cpp -o test &#96;pkg-config --cflags --libs opencv&#96;</span><br></pre></td></tr></table></figure>出现类似下面错误:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libopencv_imgcodecs.so<span class="number">.3</span><span class="number">.4</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>解决方法：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/opencv.conf&#x27; </span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新电脑重新搭建Blog</title>
      <link href="2020/12/05/%E5%85%B6%E5%AE%83/Blog/%E6%96%B0%E7%94%B5%E8%84%91%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BABlog/"/>
      <url>2020/12/05/%E5%85%B6%E5%AE%83/Blog/%E6%96%B0%E7%94%B5%E8%84%91%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BABlog/</url>
      
        <content type="html"><![CDATA[<p>要点：在新的电脑上重新搭建自己的博客平台</p><a id="more"></a><ol><li>下载安装<code>Node.js</code>  <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装 <code>hexo</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li>下载blog源代码</li><li>进入blog源码目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li>正常使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s <span class="comment"># 测试</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QGLViewer库的使用（更新...）</title>
      <link href="2020/06/22/%E5%BC%80%E5%8F%91/QT/QGLViewer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2020/06/22/%E5%BC%80%E5%8F%91/QT/QGLViewer%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本篇文章内容：</p><ul><li>QGLViewer环境的搭建</li></ul><p>下次更新</p><a id="more"></a><h2 id="QGLViewer-的安装"><a href="#QGLViewer-的安装" class="headerlink" title="QGLViewer 的安装"></a>QGLViewer 的安装</h2><p>参考<a href="http://libqglviewer.com/compilation.html">官网的教程</a>基本都可以编译成功，我用QT编译的时候出现“无法打开../../QGLViewer.lib”我还以为是失败了，后来用VS中的QT插件打开编译，没有抱任何问题。（注意选对平台和版本）。编译完成后将<code>QGLViewer2.lib</code>和<code>QGLViewer2.dll</code>还有头文件都可以拷出去形成自己的最终的库，方便其他工程使用。</p><h2 id="关于QGLViewer的cmake工程"><a href="#关于QGLViewer的cmake工程" class="headerlink" title="关于QGLViewer的cmake工程"></a>关于QGLViewer的cmake工程</h2><ol><li><p>首先是 QGLViewerConfig.cmake（来源CGAL中的<code>FindQGLViewer.cmake</code>）</p><details red><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - Try to find QGLViewer</span></span><br><span class="line"><span class="comment"># Once done this will define</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  QGLVIEWER_FOUND - system has QGLViewer</span></span><br><span class="line"><span class="comment">#  QGLVIEWER_INCLUDE_DIR - the QGLViewer include directory</span></span><br><span class="line"><span class="comment">#  QGLVIEWER_LIBRARIES - Link these to use QGLViewer</span></span><br><span class="line"><span class="comment">#  QGLVIEWER_DEFINITIONS - Compiler switches required for using QGLViewer</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">POLICY</span> CMP0072)</span><br><span class="line">  <span class="comment"># About the use of OpenGL</span></span><br><span class="line">  <span class="keyword">cmake_policy</span>(<span class="keyword">SET</span> CMP0072 NEW)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">find_package</span>(OpenGL QUIET)</span><br><span class="line"><span class="keyword">find_package</span>(Qt5 QUIET COMPONENTS OpenGL Xml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># first look in user defined locations</span></span><br><span class="line"><span class="keyword">find_path</span>(QGLVIEWER_INCLUDE_DIR</span><br><span class="line">          NAMES QGLViewer/qglviewer.h</span><br><span class="line">          NO_DEFAULT_PATH</span><br><span class="line">          PATHS ENV QGLVIEWERROOT</span><br><span class="line">                /usr/local/<span class="keyword">include</span></span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(QGLVIEWER_LIBRARY_RELEASE</span><br><span class="line">             NAMES qglviewer-qt5 qglviewer QGLViewer-qt5 QGLViewer QGLViewer2-qt5 QGLViewer2</span><br><span class="line">             NO_DEFAULT_PATH</span><br><span class="line">             PATHS ENV QGLVIEWERROOT</span><br><span class="line">                   ENV LD_LIBRARY_PATH</span><br><span class="line">                   ENV LIBRARY_PATH</span><br><span class="line">                   /usr/local/lib</span><br><span class="line">             PATH_SUFFIXES QGLViewer QGLViewer/release</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(QGLVIEWER_LIBRARY_DEBUG</span><br><span class="line">             NAMES dqglviewer dQGLViewer-qt5 dQGLViewer dQGLViewer2-qt5 dQGLViewer2 QGLViewerd2-qt5 QGLViewerd2</span><br><span class="line">             NO_DEFAULT_PATH</span><br><span class="line">             PATHS /usr/local/lib</span><br><span class="line">                   ENV QGLVIEWERROOT</span><br><span class="line">                   ENV LD_LIBRARY_PATH</span><br><span class="line">                   ENV LIBRARY_PATH</span><br><span class="line">             PATH_SUFFIXES QGLViewer QGLViewer/debug</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="comment">#now try the standard paths</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> QGLVIEWER_INCLUDE_DIR <span class="keyword">OR</span> <span class="keyword">NOT</span> QGLVIEWER_LIBRARY_RELEASE <span class="keyword">OR</span> <span class="keyword">NOT</span> QGLVIEWER_LIBRARY_DEBUG)</span><br><span class="line"><span class="keyword">find_path</span>(QGLVIEWER_INCLUDE_DIR</span><br><span class="line">          NAMES QGLViewer/qglviewer.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(QGLVIEWER_LIBRARY_RELEASE</span><br><span class="line">             NAMES qglviewer-qt5 qglviewer QGLViewer-qt5 QGLViewer QGLViewer2-qt5 QGLViewer2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(QGLVIEWER_LIBRARY_DEBUG</span><br><span class="line">             NAMES dqglviewer dQGLViewer-qt5 dQGLViewer dQGLViewer2-qt5 dQGLViewer2 QGLViewerd2-qt5 QGLViewerd2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(QGLVIEWER_LIBRARY_RELEASE)</span><br><span class="line">  <span class="keyword">if</span>(QGLVIEWER_LIBRARY_DEBUG)</span><br><span class="line">    <span class="keyword">set</span>(QGLVIEWER_LIBRARIES_ Qt5::Xml Qt5::OpenGL <span class="variable">$&#123;OPENGL_LIBRARIES&#125;</span> optimized <span class="variable">$&#123;QGLVIEWER_LIBRARY_RELEASE&#125;</span> debug <span class="variable">$&#123;QGLVIEWER_LIBRARY_DEBUG&#125;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(QGLVIEWER_LIBRARIES_ Qt5::Xml Qt5::OpenGL <span class="variable">$&#123;OPENGL_LIBRARIES&#125;</span> <span class="variable">$&#123;QGLVIEWER_LIBRARY_RELEASE&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(QGLVIEWER_LIBRARIES <span class="variable">$&#123;QGLVIEWER_LIBRARIES_&#125;</span> CACHE FILEPATH <span class="string">&quot;The QGLViewer library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(QGLVIEWER_INCLUDE_DIR <span class="keyword">AND</span> QGLVIEWER_LIBRARIES)</span><br><span class="line">   <span class="keyword">SET</span>(QGLVIEWER_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(QGLVIEWER_INCLUDE_DIR <span class="keyword">AND</span> QGLVIEWER_LIBRARIES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(QGLVIEWER_FOUND)</span><br><span class="line">  <span class="keyword">IF</span>(<span class="keyword">NOT</span> QGLViewer_FIND_QUIETLY)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;Found QGLViewer: $&#123;QGLVIEWER_LIBRARIES&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> QGLViewer_FIND_QUIETLY)</span><br><span class="line"><span class="keyword">ELSE</span>(QGLVIEWER_FOUND)</span><br><span class="line">  <span class="keyword">IF</span>(QGLViewer_FIND_REQUIRED)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;Could not find QGLViewer&quot;</span>)</span><br><span class="line">  <span class="keyword">ENDIF</span>(QGLViewer_FIND_REQUIRED)</span><br><span class="line"><span class="keyword">ENDIF</span>(QGLVIEWER_FOUND)</span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p><code>CMakeListx.txt</code>的简单示例</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(QGLViewer_Test)</span><br><span class="line"><span class="keyword">find_package</span>(QGLViewer REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;QGLVIEWER_INCLUDE_DIR&#125;   $&#123;QGLVIEWER_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(../<span class="keyword">include</span> <span class="variable">$&#123;QGLVIEWER_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(QGLViewer_Test main.cpp simpleViewer.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(QGLViewer_Test <span class="variable">$&#123;QGLVIEWER_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>道格拉斯算法的使用</title>
      <link href="2020/06/22/%E5%BC%80%E5%8F%91/C++/Douglas-Peuker%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/22/%E5%BC%80%E5%8F%91/C++/Douglas-Peuker%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本篇文章内容：</p><ul><li>道格拉斯算法的内容</li><li>算法的普通实现</li><li>在2D和3D空间中的实现</li></ul><a id="more"></a><h2 id="道格拉斯算法的内容"><a href="#道格拉斯算法的内容" class="headerlink" title="道格拉斯算法的内容"></a>道格拉斯算法的内容</h2><p>参考：<a href="https://baike.baidu.com/item/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/3739771?fromtitle=%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E7%AE%97%E6%B3%95&fromid=16245290&fr=aladdin">道格拉斯算法-百度百科</a></p><h2 id="道格拉斯-Douglas-Peuker-算法-的递归实现"><a href="#道格拉斯-Douglas-Peuker-算法-的递归实现" class="headerlink" title="道格拉斯 Douglas-Peuker 算法 的递归实现"></a>道格拉斯 Douglas-Peuker 算法 的递归实现</h2><p><a href="https://www.cnblogs.com/grandyang/p/9461484.html">Largest Triangle Area 最大的三角区域</a></p><details red><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPoint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief CPointRarefyOprt::PerpendicularDistance 计算点到首尾连线间的距离(垂距)</span></span><br><span class="line"><span class="comment"> * @param Point1                                  首坐标</span></span><br><span class="line"><span class="comment"> * @param Point2                                  尾坐标</span></span><br><span class="line"><span class="comment"> * @param Point                                   要计算到直线距离的点</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PerpendicularDistance</span><span class="params">(<span class="keyword">const</span> QPoint &amp;Point1, <span class="keyword">const</span> QPoint &amp;Point2, <span class="keyword">const</span> QPoint &amp;Point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//行列式算法的展开</span></span><br><span class="line">    <span class="keyword">double</span> area = fabsf(<span class="number">0.5</span> * (Point1.x * Point2.y + Point2.x * Point.y + Point.x * Point1.y - Point2.x * Point1.y - Point.x * Point2.y - Point1.x * Point.y));</span><br><span class="line">    <span class="keyword">double</span> bottom = sqrtf(<span class="built_in">pow</span>(Point1.x - Point2.x, <span class="number">2</span>) + <span class="built_in">pow</span>(Point1.y - Point2.y, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">double</span> height = area / bottom * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief DouglasPeuckerReduction  道格拉斯——普克算法</span></span><br><span class="line"><span class="comment"> * @param Points                   要进行简化的曲线的点列</span></span><br><span class="line"><span class="comment"> * @param startPoint               进行此算法的曲线开始的点的数组下标</span></span><br><span class="line"><span class="comment"> * @param endPoint                 进行此算法的曲线结束的点的数组下标</span></span><br><span class="line"><span class="comment"> * @param tolerance                极差D(阈值)</span></span><br><span class="line"><span class="comment"> * @param resultPoints             得到的简化的曲线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DouglasPeuckerReduction</span><span class="params">(QVector&lt;QPoint&gt; Points,<span class="keyword">int</span> startPoint</span></span></span><br><span class="line"><span class="function"><span class="params">                             ,<span class="keyword">int</span> endPoint, <span class="keyword">double</span> tolerance,QVector&lt;QPoint&gt; resultPoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> maxDistance = <span class="number">0</span>; <span class="comment">//最远距离(垂距)</span></span><br><span class="line">    <span class="keyword">int</span> indexFarthest = <span class="number">-1</span>;  <span class="comment">//最远距离点的数组下标</span></span><br><span class="line">    <span class="keyword">if</span>(endPoint-startPoint&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(endPoint==startPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//endPoint==startPoint相等时，只有一个点时，所以添加一个点</span></span><br><span class="line">            resultPoints.append(points[startPoint]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有两个点时，添加两个点</span></span><br><span class="line">            resultPoints.append(points[startPoint]);</span><br><span class="line">            resultPoints.append(points[endPoint]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小于等于两个点时，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = startPoint; index &lt; endPoint; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> distance = PerpendicularDistance(points[startPoint],points[endPoint],points[index]);</span><br><span class="line">        <span class="keyword">if</span> (distance &gt; maxDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当新得到的点的垂距大于之前的最大垂距时，更新最大垂距，并且更新最大垂距点的下标</span></span><br><span class="line">           maxDistance = distance;</span><br><span class="line">           indexFarthest = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxDistance &gt; tolerance &amp;&amp; indexFarthest != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对起始点到最大垂距点之间的点重复进行道格拉斯——普克算法</span></span><br><span class="line">        DouglasPeuckerReduction(points, startPoint,indexFarthest<span class="number">-1</span>, tolerance, resultPoints);</span><br><span class="line">        <span class="comment">//将最大垂距点保留</span></span><br><span class="line">        resultPoints.append(points[indexFarthest]);</span><br><span class="line">        <span class="comment">//对最大垂距点到结束点之间的点重复进行道格拉斯——普克算法</span></span><br><span class="line">        DouglasPeuckerReduction(points, indexFarthest+<span class="number">1</span>,endPoint, tolerance, resultPoints);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="道格拉斯算法在点云简化中的实现"><a href="#道格拉斯算法在点云简化中的实现" class="headerlink" title="道格拉斯算法在点云简化中的实现"></a>道格拉斯算法在点云简化中的实现</h2><p>参考<a href="https://github.com/JoeyAndres/LineSimplification/tree/33d849e0e2c364ebce2b4d33a925f109197a71cd">LineSimplification</a>的代码，包括2D和3D点中算法的应用<br>网盘备份地址：链接：<a href="https://pan.baidu.com/s/1PqmIGwZJUrq7djdspOZJ3w">https://pan.baidu.com/s/1PqmIGwZJUrq7djdspOZJ3w</a> 提取码：6cut</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github开源人脸识别项目face_recognition</title>
      <link href="2020/06/15/%E5%BC%80%E5%8F%91/AI/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
      <url>2020/06/15/%E5%BC%80%E5%8F%91/AI/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>功能介绍：</p><ul><li>从图片中定位人脸</li><li>识别人脸关键点</li><li>人脸识别人物</li><li>…</li></ul><a id="more"></a><p>参考：<a href="https://zhuanlan.zhihu.com/p/45827914">https://zhuanlan.zhihu.com/p/45827914</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="1-编译dlib库"><a href="#1-编译dlib库" class="headerlink" title="1.编译dlib库"></a>1.编译dlib库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/davisking/dlib.git</span><br><span class="line">cd dlib</span><br><span class="line">mkdir build; cd build; cmake ..; cmake --build .</span><br><span class="line">cd ..</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p>安装后，可以在python中<code>import dlib</code>测试是否成功</p><h4 id="安装-face-recognition"><a href="#安装-face-recognition" class="headerlink" title="安装 face_recognition"></a>安装 <code>face_recognition</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install face_recognition <span class="comment">#下载太慢</span></span><br><span class="line"><span class="comment">#可能需要这样做</span></span><br><span class="line">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple face_recognition</span><br></pre></td></tr></table></figure><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><h4 id="face-detection-和-face-recognition命令行"><a href="#face-detection-和-face-recognition命令行" class="headerlink" title="face_detection 和 face_recognition命令行"></a>face_detection 和 face_recognition命令行</h4><h4 id="Python代码中测试"><a href="#Python代码中测试" class="headerlink" title="Python代码中测试"></a>Python代码中测试</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT动画操作</title>
      <link href="2020/05/11/%E5%BC%80%E5%8F%91/QT/QT%E5%8A%A8%E7%94%BB%E6%93%8D%E4%BD%9C/"/>
      <url>2020/05/11/%E5%BC%80%E5%8F%91/QT/QT%E5%8A%A8%E7%94%BB%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要内容：</p><ul><li>QT的动画实现</li></ul><a id="more"></a><p>动画框架基础由基类QAbstractAnimation以及它的两个子类QVariantAnimation、QAnimationGroup组成。</p><p><img src="/assets/blog/QT/QT_Animation.png" class="lazyload" data-srcset="/assets/blog/QT/QT_Animation.png" srcset="data:image/png;base64,666" alt=""></p><h2 id="QT动画属性"><a href="#QT动画属性" class="headerlink" title="QT动画属性"></a>QT动画属性</h2><p>QPropertyAnimation类能够修改Qt属性值<br>示例如下，将button在10秒的持续时间从屏幕的左上角移动到(250, 250)点处。从开始位置到结束位置之间时间是均匀分配的，可以称为是线性的</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Button&quot;</span>)</span></span>;</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="function">QPropertyAnimation <span class="title">animation</span><span class="params">(&amp;button, <span class="string">&quot;geometry&quot;</span>)</span></span>;</span><br><span class="line">animation.setDuration(<span class="number">10000</span>);</span><br><span class="line">animation.setStartValue(QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">animation.setEndValue(QRect(<span class="number">250</span>, <span class="number">250</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure>              </div>            </details><p>另一种持续时间非均匀变化的例子如下，在前8秒移动到一个位置，在后2秒移动到原来位置</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Button&quot;</span>)</span></span>;</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="function">QPropertyAnimation <span class="title">animation</span><span class="params">(&amp;button, <span class="string">&quot;geometry&quot;</span>)</span></span>;</span><br><span class="line">animation.setDuration(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">animation.setKeyValueAt(<span class="number">0</span>, QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">animation.setKeyValueAt(<span class="number">0.8</span>, QRect(<span class="number">250</span>, <span class="number">250</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">animation.setKeyValueAt(<span class="number">1</span>, QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure>              </div>            </details><p>对于没有声明动画属性的QObject对象中，动画操作其中的值时，需要为该值设置个能进行修改的函数。所以可以进行子类化，在该类中包含声明属性的值并且有个设置函数。每个Qt属性需要一个获取值的访问函数，因此如果类本身没提供对该值的访问函数的话，你自己就需要提供一个。<br>如下代码例子中，我们子类化QGraphicsRectItem类，并且定义了”geometry”属性。即使QGraphicsRectItem没有提供”geometry”属性，我们也可以动画操作MyGraphicsRectItem的位置信息了。</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGraphicsRectItem</span> :</span> <span class="keyword">public</span> QObject, <span class="keyword">public</span> QGraphicsRectItem</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="缓和曲线"><a href="#缓和曲线" class="headerlink" title="缓和曲线"></a>缓和曲线</h2><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Animated Button&quot;</span>)</span></span>;</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="function">QPropertyAnimation <span class="title">animation</span><span class="params">(&amp;button, <span class="string">&quot;geometry&quot;</span>)</span></span>;</span><br><span class="line">animation.setDuration(<span class="number">3000</span>);</span><br><span class="line">animation.setStartValue(QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">animation.setEndValue(QRect(<span class="number">250</span>, <span class="number">250</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">animation.setEasingCurve(QEasingCurve::OutBounce);<span class="comment">//设置缓和曲线</span></span><br><span class="line"></span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure>              </div>            </details><p>以上的例子中，动画沿着OutBounce曲线，该曲线样式是到结束处会弹跳起来像个弹跳球。QEasingCurve类有大量供选择的曲线，它们被定义成QEasingCurve::Type枚举。如果你需要另外的曲线样式，也可以自己实现一个，然后用QEasingCurve注册它既可。</p><h2 id="动画分组"><a href="#动画分组" class="headerlink" title="动画分组"></a>动画分组</h2><p>动画分组主要分为两种，并行(QParallelAnimationGroup)和串行(QSequentialAnimationGroup)</p><h3 id="并行分组动画"><a href="#并行分组动画" class="headerlink" title="并行分组动画"></a>并行分组动画</h3><p>组内动画可以同时进行，示例如下</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *bonnie = <span class="keyword">new</span> QPushButton(<span class="string">&quot;Bonnie&quot;</span>);</span><br><span class="line">bonnie-&gt;show();</span><br><span class="line"></span><br><span class="line">QPushButton *clyde = <span class="keyword">new</span> QPushButton(<span class="string">&quot;Clyde&quot;</span>);</span><br><span class="line">clyde-&gt;show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画一</span></span><br><span class="line">QPropertyAnimation *anim1 = <span class="keyword">new</span> QPropertyAnimation(bonnie, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line">anim1-&gt;setDuration(<span class="number">3000</span>);</span><br><span class="line">anim1-&gt;setStartValue(QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">anim1-&gt;setEndValue(QRect(<span class="number">500</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">// 动画二</span></span><br><span class="line">QPropertyAnimation *anim2 = <span class="keyword">new</span> QPropertyAnimation(clyde, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line">anim2-&gt;setDuration(<span class="number">3000</span>);</span><br><span class="line">anim2-&gt;setStartValue(QRect(<span class="number">500</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">anim2-&gt;setEndValue(QRect(<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">QParallelAnimationGroup *group = <span class="keyword">new</span> QParallelAnimationGroup;</span><br><span class="line">group-&gt;addAnimation(anim1);</span><br><span class="line">group-&gt;addAnimation(anim2);</span><br><span class="line"></span><br><span class="line">group-&gt;start();</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="串行分组动画"><a href="#串行分组动画" class="headerlink" title="串行分组动画"></a>串行分组动画</h3><p>组内动画按一定顺序执行，示例如下：</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Animated Button&quot;</span>)</span></span>;</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="function">QPropertyAnimation <span class="title">anim1</span><span class="params">(&amp;button, <span class="string">&quot;geometry&quot;</span>)</span></span>;</span><br><span class="line">anim1.setDuration(<span class="number">3000</span>);</span><br><span class="line">anim1.setStartValue(QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">anim1.setEndValue(QRect(<span class="number">500</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">QPropertyAnimation <span class="title">anim2</span><span class="params">(&amp;button, <span class="string">&quot;geometry&quot;</span>)</span></span>;</span><br><span class="line">anim2.setDuration(<span class="number">3000</span>);</span><br><span class="line">anim2.setStartValue(QRect(<span class="number">500</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">anim2.setEndValue(QRect(<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">QSequentialAnimationGroup group;</span><br><span class="line"></span><br><span class="line">group.addAnimation(&amp;anim1);</span><br><span class="line">group.addAnimation(&amp;anim2);</span><br><span class="line"></span><br><span class="line">group.start();</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="动画状态机"><a href="#动画状态机" class="headerlink" title="动画状态机"></a>动画状态机</h2><p>使用状态机时，我们可以使用QSignalTransition或QEventTransition类将一个或者多个动画与状态之间的切换中进行关联。这些类继承于QAbstractTransition，QAbstractTransition类提供了函数addAnimation()，该函数在状态切换发生的情况下能触发一个或多个被附加的动画。<br>以下示例实现了，点击按钮会移动到一个位置，再点击按钮又会回到原来的位置</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> QPushButton(<span class="string">&quot;Animated Button&quot;</span>);</span><br><span class="line">button-&gt;show();</span><br><span class="line"></span><br><span class="line">QStateMachine *machine = <span class="keyword">new</span> QStateMachine;<span class="comment">//创建状态机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种状态时按钮的位置</span></span><br><span class="line">QState *state1 = <span class="keyword">new</span> QState(machine);</span><br><span class="line">state1-&gt;assignProperty(button, <span class="string">&quot;geometry&quot;</span>, QRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line">machine-&gt;setInitialState(state1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种状态时按钮的位置</span></span><br><span class="line">QState *state2 = <span class="keyword">new</span> QState(machine);</span><br><span class="line">state2-&gt;assignProperty(button, <span class="string">&quot;geometry&quot;</span>, QRect(<span class="number">250</span>, <span class="number">250</span>, <span class="number">100</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//当点击按钮时会触发第二种状态</span></span><br><span class="line">QSignalTransition *transition1 = state1-&gt;addTransition(button,</span><br><span class="line">    SIGNAL(clicked()), state2);</span><br><span class="line">transition1-&gt;addAnimation(<span class="keyword">new</span> QPropertyAnimation(button, <span class="string">&quot;geometry&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//当点击按钮时会触发第一种状态</span></span><br><span class="line">QSignalTransition *transition2 = state2-&gt;addTransition(button,</span><br><span class="line">    SIGNAL(clicked()), state1);</span><br><span class="line">transition2-&gt;addAnimation(<span class="keyword">new</span> QPropertyAnimation(button, <span class="string">&quot;geometry&quot;</span>));</span><br><span class="line"></span><br><span class="line">machine-&gt;start();</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> QT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新版本Blog主题写作指南</title>
      <link href="2020/04/25/%E5%85%B6%E5%AE%83/Blog/%E6%96%B0%E7%89%88Blog%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
      <url>2020/04/25/%E5%85%B6%E5%AE%83/Blog/%E6%96%B0%E7%89%88Blog%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>今天更新了之前用的Blog主题，现在是最新的<code>2.0</code>版本 —— <em>Volantis</em>,此版本中更新了不少的功能，在此将常用的一些操作记录下来，以便今后查询</p><p class='p center logo large'>Volantis</p><span class='btn center large'><a class="button" href='https://volantis.js.org/tag-plugins/' title='更多新功能请点击'><i class='fas fa-download'></i>更多新功能请点击</a></span><a id="more"></a><h2 id="文本和段落"><a href="#文本和段落" class="headerlink" title="文本和段落"></a>文本和段落</h2><p>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</p><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><div class="note "><p>为简单的一句话提供的简便写法。</p></div><div class="note success"><p>支持同样丰富的参数。</p></div><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><h3 id="基础按钮"><a href="#基础按钮" class="headerlink" title="基础按钮"></a>基础按钮</h3><p>不设置任何参数的 <span class='btn'><a class="button" href='/' title='按钮'>按钮</a></span> 适合融入段落中。</p><p>regular 按钮适合独立于段落之外：</p><span class='btn regular'><a class="button" href='https://xaoxuu.com' title='示例博客'><i class='fas fa-play-circle'></i>示例博客</a></span><p>large 按钮更具有强调作用，建议搭配 center 使用：</p><span class='btn center large'><a class="button" href='https://volantis.js.org/getting-started/' title='开始使用'><i class='fas fa-download'></i>开始使用</a></span><h3 id="富文本按钮"><a href="#富文本按钮" class="headerlink" title="富文本按钮"></a>富文本按钮</h3><div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div><div class="btns circle grid3">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><div class='dropmenu-wrapper'>              <div class='dropmenu'>                <a>下拉菜单</a>                <ul class='list-v'>                  <li>                <a class='menuitem' href='https://github.com/xaoxuu/hexo-theme-volantis/' title='主题源码'>                  <i class='fas fa-file-code fa-fw'></i>                  主题源码                </a>              </li><li>                <a class='menuitem' href='https://github.com/xaoxuu/hexo-theme-volantis/releases/' title='更新日志'>                  <i class='fas fa-clipboard-list fa-fw'></i>                  更新日志                </a>              </li><hr><li>              <a class='menuitem'>                <i class=' fas fa-question-circle fa-fw'></i>                有疑问？              </a>              <ul class='list-v'>                <li>                <a class='menuitem' href='/faqs/' title='看 FAQ'>                  看 FAQ                </a>              </li><li>                <a class='menuitem' href='https://github.com/xaoxuu/volantis-docs/' title='看 本站源码'>                  看 本站源码                </a>              </li><li>                <a class='menuitem' href='https://github.com/xaoxuu/hexo-theme-volantis/issues/' title='提 Issue'>                  提 Issue                </a>              </li>              </ul>            </li>                </ul>              </div>            </div><h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><details ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" srcset="data:image/png;base64,666" alt=""></p>              </div>            </details><details cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details green><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><details yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选） %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 时间节点（标题） %&#125;</span><br><span class="line"></span><br><span class="line">正文内容</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 时间节点（标题） %&#125;</span><br><span class="line"></span><br><span class="line">正文内容</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></p></div><div class="body"><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></p></div><div class="body"><p>不需要额外处理。</p></div></div><div class="timenode"><div class="meta"><p><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></p></div><div class="body"><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><h3 id="github-卡片"><a href="#github-卡片" class="headerlink" title="github 卡片"></a>github 卡片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名&#x2F;仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&show_owner=true" srcset="data:image/png;base64,666"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=vue&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=vue&show_owner=true" srcset="data:image/png;base64,666"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=buefy&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=buefy&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-light&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-light&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=onedark&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=onedark&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-dark&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-dark&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=algolia&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=algolia&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=calm&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=calm&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr></tbody></table><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true" srcset="data:image/png;base64,666"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true" srcset="data:image/png;base64,666"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true" srcset="data:image/png;base64,666"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true" srcset="data:image/png;base64,666"/></a></td></tr></tbody></table><h3 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h3><div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1">栏目1</a></li><li class="tab"><a class="#tab-id-2">栏目2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><p>。。。</p></div><div class="tab-pane" id="tab-id-2"><p>！！！</p></div></div></div><p>更多查看：(tag-Plugins)[<a href="https://volantis.js.org/tag-plugins/]">https://volantis.js.org/tag-plugins/]</a></p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" srcset="data:image/png;base64,666"/></div></div><p>指定宽度：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" srcset="data:image/png;base64,666"/></div></div><p>指定宽度并添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/06/zdeQiOY9rBCjhDR.jpg" srcset="data:image/png;base64,666"/></div></div><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><div class="note "><p>注意要在文章开头添加 mathjax: true</p></div><p>$t+1=2$</p><p>$$<br>\mbox{积累因子}=\begin{cases}<br>1+ni &amp; \mbox{单利}\\<br>(1+i)^n &amp; \mbox{复利}<br>\end{cases}<br>$$</p><p>$$<br>\begin{equation}<br>\sum_{i=0}^n F_i \cdot \phi (H, p_i) - \sum_{i=1}^n a_i \cdot ( \tilde{x_i}, \tilde{y_i}) + b_i \cdot ( \tilde{x_i}^2 , \tilde{y_i}^2 )<br>\end{equation}<br>$$<br>$$<br>\begin{equation}<br>\beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i))<br>\end{equation}<br>$$</p><h2 id="代码块高亮显示"><a href="#代码块高亮显示" class="headerlink" title="代码块高亮显示"></a>代码块高亮显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line marked">   print(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> n&gt;<span class="number">0</span>:</span><br><span class="line marked">   print(<span class="string">&quot;He\nll\no \nWo\nrl\nd&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;Hello World&quot;</span>:</span><br><span class="line marked">   print(c)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客网错题收录</title>
      <link href="2020/03/18/%E5%BC%80%E5%8F%91/C++/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98/"/>
      <url>2020/03/18/%E5%BC%80%E5%8F%91/C++/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>牛客网错题整理收录</strong>——软件工程师面试题收录，持续更新中…</p><a id="more"></a><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>在C++中常量可分为6种,它们是整型常量、实型常量、字符型常量、字符串常量、符号常量、逻辑型常量.</li><li>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例</li><li>C++11 STL中的容器 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">==================================================</span><br><span class="line">一、顺序容器：</span><br><span class="line"><span class="built_in">vector</span>：可变大小数组；</span><br><span class="line"><span class="built_in">deque</span>：双端队列；</span><br><span class="line"><span class="built_in">list</span>：双向链表；</span><br><span class="line">forward_list：单向链表；</span><br><span class="line"><span class="built_in">array</span>：固定大小数组；</span><br><span class="line"><span class="built_in">string</span>：与<span class="built_in">vector</span>相似的容器，但专门用于保存字符。</span><br><span class="line">==================================================</span><br><span class="line">二、关联容器：</span><br><span class="line">按关键字有序保存元素：（底层实现为红黑树）</span><br><span class="line"><span class="built_in">map</span>：关联数组；保存关键字-值对；</span><br><span class="line"><span class="built_in">set</span>：关键字即值，即只保存关键字的容器；</span><br><span class="line"><span class="built_in">multimap</span>：关键字可重复的<span class="built_in">map</span>；</span><br><span class="line"><span class="built_in">multiset</span>：关键字可重复的<span class="built_in">set</span>；</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">无序集合：</span><br><span class="line"><span class="built_in">unordered_map</span>：用哈希函数组织的<span class="built_in">map</span>；</span><br><span class="line"><span class="built_in">unordered_set</span>：用哈希函数组织的<span class="built_in">set</span>；</span><br><span class="line"><span class="built_in">unordered_multimap</span>：哈希组织的<span class="built_in">map</span>；关键字可以重复出现；</span><br><span class="line"><span class="built_in">unordered_multiset</span>：哈希组织的<span class="built_in">set</span>；关键字可以重复出现。</span><br><span class="line">==================================================</span><br><span class="line">三、其他项：</span><br><span class="line"><span class="built_in">stack</span>、<span class="built_in">queue</span>、valarray、<span class="built_in">bitset</span></span><br></pre></td></tr></table></figure></li><li>还可以这样定义对象数组 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>;</span></span><br><span class="line">Test t[<span class="number">2</span>]=&#123;Test(<span class="number">1</span>,<span class="number">2</span>),Test(<span class="number">3</span>,<span class="number">4</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li>数据结构中data的处理方式:编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问.data是一个柔性数组，可变大小 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>s1和s2是两个结构类型变量，若要使赋值s1=s2合法，则它们必须是同一结构类型的变量</li></ol><h3 id="运算符问题"><a href="#运算符问题" class="headerlink" title="运算符问题"></a>运算符问题</h3><p>C语言中对赋值运算的优先级较低，只比逗号运算符高，且运算顺序是自右向左</p><ol><li>以下程序的输出结果是（16）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    a+=(a=<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a+=(a=8) –&gt; a=a+(a=8) –&gt; a=8+8=16</p></blockquote></li><li>运算符重载<br>(1)只能使用成员函数重载的运算符有：=、()、[]、-&gt;、new、delete。<br>(2)单目运算符最好重载为成员函数。<br>(3) 对于复合的赋值运算符如+=、-=、*=、/=、&amp;=、!=、~=、%=、&gt;&gt;=、&lt;&lt;=建议重载为成员函数。<br>(4) 对于其它运算符，建议重载为友元函数<br>关于运算符重载</li></ol><ul><li>无参函数只能用来定义单目运算符，当前对象作为操作数</li><li>单参函数可定义双目运算符，当前对象作为左操作数，形参作为右操作数</li><li>定义后置“++”或后置“一一”运算是特例，它们是单目运算符，但需要一个int形参</li></ul><ol start="3"><li>除了类属关系运算符”.“、成员指针运算符”.*“、作用域运算符”::“、sizeof运算符和三目运算符”?:“以外，C++中的所有运算符都可以重载</li></ol><h3 id="const问题"><a href="#const问题" class="headerlink" title="const问题"></a>const问题</h3><ul><li>有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员</li><li>常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数</li></ul><ol><li>const表面含义是个常量，但实际上还是占据一个内存位置的变量，但是它的值一般实在编译时期就决定了</li></ol><h3 id="虚函数问题"><a href="#虚函数问题" class="headerlink" title="虚函数问题"></a>虚函数问题</h3><ul><li>绝不在构造函数和析构函数中调用virtual函数。</li></ul><ol start="2"><li>即使不进行强制类型转换，在进行指针赋值运算时，指针变量的基类型也可以不同（X  错）</li></ol><h3 id="指针问题"><a href="#指针问题" class="headerlink" title="指针问题"></a>指针问题</h3><ul><li>p=NULL 和 p=0 或 p=’\0’ 等价</li></ul><h3 id="static问题"><a href="#static问题" class="headerlink" title="static问题"></a>static问题</h3><p>对类中的数据成员进行初始化的条件是： </p><ol><li>必须是一个（static）静态成员。对于非静态成员不能在类定义中进行初始化。 </li><li>静态成员的声明中必须是有 const 限定。非 const 的静态成员不能在类定义中进行初始化。 </li><li>静态成员的类型必须为整型或者是枚举型。其它类型（如浮点型、数组、指针等）不能在类定义中进行初始化。 </li><li>只能使用一个整型常量表达式（integral constant expression）来进行初始化</li></ol><h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3><ol><li>f(2486)的返回值是(7)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(m=<span class="number">0</span>;n;++m)</span><br><span class="line">   &#123;</span><br><span class="line">     n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>n&amp;=(n-1)相当于n=n&amp;(n-1),执行一次也就相当于把二进制中的最低位的1置为0；循环执行，也就是计算2468的二进制中有多少个1.<br>2486=2048 + 256 + 128 + 32 + 16 + 4 + 2 七个1</li><li>fseek(fp,-20L,2)的含义是将文件指针fp移动到文件末尾倒数第20个字符处<h3 id="volitle问题"><a href="#volitle问题" class="headerlink" title="volitle问题"></a>volitle问题</h3></li><li>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。<br>对于一般变量：为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中。以后再取变量值时，就直接从寄存器中取值。</li><li>一个参数既可以是const也可以是volatile：一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile的编写</title>
      <link href="2020/03/13/%E5%BC%80%E5%8F%91/Linux/Makefile/"/>
      <url>2020/03/13/%E5%BC%80%E5%8F%91/Linux/Makefile/</url>
      
        <content type="html"><![CDATA[<p><strong>Makefile编程</strong></p><a id="more"></a><h3 id="引用其它的-Makefile"><a href="#引用其它的-Makefile" class="headerlink" title="引用其它的 Makefile"></a>引用其它的 Makefile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include foo.make *.mk $(bar)</span><br></pre></td></tr></table></figure><p>如果文件都没有指定绝对路径或是相对路径的话， make 会在当前目录下首先寻找，如果当前目录下没有找到，那么， make 还会在下面的几个目录下找：</p><ol><li>如果 make 执行时，有“-I”或“–include-dir”参数，那么 make 就会在这个参数所指定的目录下去寻找。</li><li>如果目录&lt;prefix&gt;/include（一般是： /usr/local/bin 或/usr/include）存在的话， make 也会去找。</li></ol><p>想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”. <code>-include &lt;filename&gt;</code></p><h3 id="make-的工作方式"><a href="#make-的工作方式" class="headerlink" title="make 的工作方式"></a>make 的工作方式</h3><p>1、读入所有的 Makefile。<br>2、读入被 include 的其它 Makefile。<br>3、初始化文件中的变量。<br>4、推导隐晦规则，并分析所有规则。<br>5、为所有的目标文件创建依赖关系链。<br>6、根据依赖关系，决定哪些目标要重新生成。<br>7、执行生成命令</p><h4 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h4><p>如果没有指明这个变量， make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么， make 就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH &#x3D; src:..&#x2F;headers</span><br></pre></td></tr></table></figure><p>上面的的定义指定两个目录，“src”和“../headers”， make 会按照这个顺序进行搜索。目录由“冒号”分隔。</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux Shell</title>
      <link href="2020/03/13/%E5%BC%80%E5%8F%91/Linux/Shell%E7%AC%94%E8%AE%B0/"/>
      <url>2020/03/13/%E5%BC%80%E5%8F%91/Linux/Shell%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>linux Shell编程</strong></p><a id="more"></a><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line"></span><br><span class="line">readonly variable_name #只读变量</span><br><span class="line">unset variable_name #删除变量，不能删除只读变量</span><br></pre></td></tr></table></figure><p>变量赋值时不需要加<code>$</code>,使用变量的时候才加美元符<code>$</code>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">your_name=&#x27;runoob&#x27; #单引号，双引号都可以</span><br><span class="line">str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash">单引号字符串中的变量是无效的，推荐用双引号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Hello, I know you are <span class="string">&quot;runoob&quot;</span>!</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取字符串长度</span></span><br><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">提取子字符串</span></span><br><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查找子字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)</span></span><br><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">数组初始化</span></span><br><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"><span class="meta">#</span><span class="bash">数组赋值</span></span><br><span class="line">array_name[0]=value0</span><br><span class="line"><span class="meta">#</span><span class="bash">读取数组</span></span><br><span class="line">exho $&#123;array_name[n]&#125;</span><br><span class="line">echo $&#123;array_name[@]&#125;#所有数组元素</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p><img src="/assets/blog/shell/parameter.PNG" class="lazyload" data-srcset="/assets/blog/shell/parameter.PNG" srcset="data:image/png;base64,666" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;执行的文件名：$0&quot;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>$\</em> 与 $@ 区别：*<br>相同点：都是引用所有参数。<br>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 郭靖     男      66.12</span></span><br></pre></td></tr></table></figure><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if…else…fi"><a href="#if…else…fi" class="headerlink" title="if…else…fi"></a>if…else…fi</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case…in…"><a href="#case…in…" class="headerlink" title="case…in…"></a>case…in…</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    ...</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">     ...</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"><span class="meta">#</span><span class="bash">第一个参数为 1 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个参数为 2 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第十个参数为 10 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第十个参数为 34 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第十一个参数为 73 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数总数有 11 个!</span></span><br><span class="line"><span class="meta">#</span><span class="bash">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span></span><br></pre></td></tr></table></figure><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read var_name #输入变量值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Window上基于QT的FFmpeg环境搭建</title>
      <link href="2020/02/27/%E5%BC%80%E5%8F%91/C++/Window%E4%B8%8A%E5%9F%BA%E4%BA%8EQT%E7%9A%84FFmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2020/02/27/%E5%BC%80%E5%8F%91/C++/Window%E4%B8%8A%E5%9F%BA%E4%BA%8EQT%E7%9A%84FFmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Window上基于QT的FFmpeg环境搭建</p><a id="more"></a><h2 id="FFmpeg的下载和安装"><a href="#FFmpeg的下载和安装" class="headerlink" title="FFmpeg的下载和安装"></a>FFmpeg的下载和安装</h2><ul><li><a href="https://ffmpeg.zeranoe.com/builds/">Windows下载地址</a>，选择电脑对应的32位或64位的<code>Shared</code>和<code>Dev</code>版本进行下载</li><li>将下载后的压缩包解压后，把其中<code>bin</code>、<code>include</code>、<code>lib</code>目录提取出来作为此工程的工作环境依赖（库，头文件），创建<code>src</code>目录作为存放源码的路径（即QT的工程）</li></ul><h2 id="QT工程的搭建（这里只用一个函数做测试）"><a href="#QT工程的搭建（这里只用一个函数做测试）" class="headerlink" title="QT工程的搭建（这里只用一个函数做测试）"></a>QT工程的搭建（这里只用一个函数做测试）</h2><p>1.在<code>.pro</code>文件里面添加对应头文件和库文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += $$PWD/../../include</span><br><span class="line">LIBS += -L$$PWD/../../lib/win32/ -lavcodec</span><br></pre></td></tr></table></figure><p>2.在源文件中添加对头文件和库的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理指令导入库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avcodec.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>3.另外可以修改项目的构建目录，让生成的可执行文件存放在对应目录下面</p><p>主程序源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要引用c语言函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理指令导入库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avcodec.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; avcodec_configuration() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来的其它程序均可在此基础上添加修改测试</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> qt </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题记录(简单篇一)</title>
      <link href="2020/01/19/%E5%BC%80%E5%8F%91/C++/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2020/01/19/%E5%BC%80%E5%8F%91/C++/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>——持续更新中（15道题）…<br>题目来源：<a href="https://leetcode-cn.com/"><em>力扣（LeetCode）</em></a></p><a id="more"></a><h3 id="力扣高频算法面试题汇总"><a href="#力扣高频算法面试题汇总" class="headerlink" title="力扣高频算法面试题汇总"></a>力扣高频算法面试题汇总</h3><h4 id="1-只出现一次的数字"><a href="#1-只出现一次的数字" class="headerlink" title="1.只出现一次的数字"></a>1.只出现一次的数字</h4><p>“给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>示例 1:<br>输入: [2,2,1]<br>输出: 1<br>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4</p><p>思路：<br>思路一：先排序，然后对 nums[i] 和 nums[i + 1]进行比较，相同则 i+=2 ,继续比较，直到有不相等的(nums[i] != nums[i + 1])，则nums[i]就是出现一次的元素。如果前面的元素都两两相等，则最后剩的那个元素就是出现一次的元素<br>思路二：使用异或的方法(异或满足交换律),出现两次的这些数字经过异或运算后结果一定是0,而任何数字与0进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="2-多数元素"><a href="#2-多数元素" class="headerlink" title="2. 多数元素"></a>2. 多数元素</h4><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2</p><p>思路1：先采用排序的算法，然后取nums[nums.size()/2]的元素即可<br>思路2：分治法<br>思路3：剔除元素法（推荐方法）：<br>在原序列中去除两个不同的元素后，原序列中的多数元素在新序列中还是多数元素。根据这个原理每次从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0后剔除这两个元素，就是重新从下一个数开始计数，遇到相同的就加1，遇到不同的就减1，总能找到最多的那个</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int max &#x3D; nums[0];</span><br><span class="line">        int count &#x3D; 1;</span><br><span class="line">        if(nums.size() &#x3D;&#x3D; 2)</span><br><span class="line">            return nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(max &#x3D;&#x3D; nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                if(count &#x3D;&#x3D; 0)</span><br><span class="line">                    max &#x3D; nums[i+1];</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="3-搜索二维矩阵"><a href="#3-搜索二维矩阵" class="headerlink" title="3. 搜索二维矩阵"></a>3. 搜索二维矩阵</h4><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:<br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p>思路：仔细观察会发现从右上角到左下角，每一个数的左边都比它小且依次增加，下面都比它大，且依次增加，所以可以跟踪法，从左下角（或者右下角）开始，比它大的往右走（往下走），比它小的往上走（往左走）</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=matrix.size()<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;matrix[<span class="number">0</span>].size())</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&gt;target) i--;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="4-合并两个有序数组"><a href="#4-合并两个有序数组" class="headerlink" title="4. 合并两个有序数组"></a>4. 合并两个有序数组</h4><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><p>思路1：把两个数组元素放在同一个数组中，无论是新的数组或是放在num1中的后面，最后再来一次排序<br>思路2: 从后面开始用两个值记录数组1和数组2的变化,需要考虑当数组1中只有空位，也就是m=0时，直接把数组2里的值放在数组1即可</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>, p = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])</span><br><span class="line">                nums1[p--] = nums2[j--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums1[p--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">            nums1[p--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5. 验证回文串"></a>5. 验证回文串</h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。<br>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>思路：两个指针指向最左边和最右边，依次往前不断比较。此处注意对字母大小写的判断（(s[m] + 32 - ‘a’) % 32)如果相等则不区分大小写也相等。</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValue</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)  <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">if</span>(!isValue(s[m]))</span><br><span class="line">                m++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isValue(s[n]))</span><br><span class="line">                n--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[m] + <span class="number">32</span> - <span class="string">&#x27;a&#x27;</span>) % <span class="number">32</span> == (s[n] + <span class="number">32</span> - <span class="string">&#x27;a&#x27;</span>) % <span class="number">32</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m++;</span><br><span class="line">                n--;  </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="6-分割回文串"><a href="#6-分割回文串" class="headerlink" title="6.分割回文串"></a>6.分割回文串</h4><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><p>示例:<br>输入: “aab”<br>输出:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]<br>思路：回溯思想。参考：<a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/">https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/</a></p><details red><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        backtrack(s, <span class="number">0</span>,  s.length(), temp, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> is, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; temp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is == len)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = is; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPar(s, is, i))</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(s.substr(is, i - is + <span class="number">1</span>));</span><br><span class="line">                backtrack(s, i+<span class="number">1</span>, len, temp, res);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPar</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(is &lt; ie)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[is] != s[ie]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            is++;ie--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="7-分割单词"><a href="#7-分割单词" class="headerlink" title="7.分割单词"></a>7.分割单词</h4><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。<br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。<br>思路：以str(begin, end)来表示str的子字符串，从前往后遍历，<br>end=1, begin=0;<br>end=2, begin=0/1;<br>end=3, begin=0/1/2;<br>…<br>end=n-1, begin=0/1/…/n-2;<br>一共是(n-1)n/2种，遍历一遍是O(n^2)的时间复杂度。逐次的去判断它们是否与字典中的某个字符串相同，如果相同了，就在end的位置标记相同(true)，end的位置一定在begin之后（begin&lt;end），那么要查询str(begin, end)，begin前面的位置一定要是true才行，意味着已经寻到了一个或者一些匹配字典的子字符串，那么就要记录是否寻得的状态。</p><details red><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || wordDict.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end = <span class="number">1</span>; end &lt;= n; end++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> begin=<span class="number">0</span>; begin&lt;end; begin++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[begin] &amp;&amp; find(wordDict.begin(), wordDict.end(), s.substr(begin, end-begin)) != wordDict.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[end] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h3><h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:所有输入只包含小写字母 a-z 。</p><p>思路：先取前两个字符串找他们的公共前缀pre，然后用pre和接下来一个作比较，找他们的公共前缀，并赋值给pre,就这样不断依次将所有有公共前缀的字符串可以找到。</p><details green><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">          <span class="keyword">int</span> count = strs.size();</span><br><span class="line">          <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">          <span class="built_in">string</span> pre = strs[<span class="number">0</span>];</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">          &#123;</span><br><span class="line">             pre = longestCommonPrefix(pre, strs[i]);</span><br><span class="line">              <span class="keyword">if</span>(pre.length() == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = (s1.size() &gt; s2.size()) ? s1.size() : s2.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; s1[i] == s2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> s1.substr(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h4><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。<br>思路：单调栈。首先将第一个元素的索引压栈，然后将其它元素与栈顶元素比较，如果比他大，则将栈中元素出栈，并计算该元素索引值与出栈元素索引值的差，并将差放入另一集合中的该位置。如果比它小则入栈。具体可以参考：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/">https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/</a></p><details red><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(T.size())</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; T[i] &gt; T[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> previousIndex = s.top();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数</a></h4><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的 十进制值 。<br>示例：<br>输入：head = [1,0,1]<br>输出：5<br>解释：二进制数 (101) 转化为十进制数 (5)<br>思路：按照十进制化二进制的方法，一般求二进制的操作（由低位到高位）是二进制数依次乘以$2^{i-1}$次方,但此题输入的二进制数是从高位到低位，若是按照那样的方式首先要得到链表的长度或是反转链表。其实画出十进制转二进制的过程可以发现化到最后商一定是0，所以往前推最后的余数（二进制的高位）$+2*0$ 得到倒数第二位的商,依次递推求和可以得到最后的十进制数</p><details yellow><summary> 点击查看代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res*<span class="number">2</span> + cur-&gt;val;<span class="comment">//此处res*2可换成(res&lt;&lt;1)</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><p>复杂度分析：<br>    时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点个数。<br>    空间复杂度：<code>O(1)</code>。</p><h4 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">1266. 访问所有点的最小时间</a></h4><p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。<br>你可以按照下面的规则在平面上移动：每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。必须按照数组中出现的顺序来访问这些点。<br>实例：<br>输入：points = [[1,1],[3,4],[-1,0]]<br>输出：7<br>解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]  </p><p>从 [1,1] 到 [3,4] 需要 3 秒 ,从 [3,4] 到 [-1,0] 需要 4 秒,一共需要 7 秒</p><p>这道题就是经典的 <strong><code>切比雪夫距离</code></strong> 问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;points)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">int</span> temp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        temp[<span class="number">0</span>] = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        temp[<span class="number">1</span>] = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = points[i][<span class="number">0</span>];</span><br><span class="line">            b = points[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            count += max(<span class="built_in">abs</span>(a - temp[<span class="number">0</span>]), <span class="built_in">abs</span>(b - temp[<span class="number">1</span>]));</span><br><span class="line">            temp[<span class="number">0</span>] = a;</span><br><span class="line">            temp[<span class="number">1</span>] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a></h4><p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p><p>示例：<br>输入: [[1,1,0],[1,0,1],[0,0,0]]<br>输出: [[1,0,0],[0,1,0],[1,1,1]]<br>解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</p><p>解题思路：如果某行处于对称位置上的数字不相同的话其实是不需要动的，翻转加互换后还是它本身；如果相同的话，就两个位置都分别互换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (len + <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == A[i][len - j - <span class="number">1</span>])</span><br><span class="line">                    A[i][j] = A[i][len - j - <span class="number">1</span>] = A[i][j] ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1108-IP-地址无效化"><a href="#1108-IP-地址无效化" class="headerlink" title="1108. IP 地址无效化"></a><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/">1108. IP 地址无效化</a></h4><p>给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。<br>所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。</p><p>示例 ：<br>输入：address = “1.1.1.1”<br>输出：”1[.]1[.]1[.]1”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = address.size(); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (address[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            address.replace(i, <span class="number">1</span>, <span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1281-整数的各位积和之差"><a href="#1281-整数的各位积和之差" class="headerlink" title="1281. 整数的各位积和之差"></a>1281. <a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/">整数的各位积和之差</a></h4><p>给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p><p>示例 1：<br>输入：n = 234<br>输出：15<br>解释：<br>各位数之积 = 2 * 3 * 4 = 24<br>各位数之和 = 2 + 3 + 4 = 9<br>结果 = 24 - 9 = 15</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, sum = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            m = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            sum += m;</span><br><span class="line">            mul *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="LCP1-猜数字"><a href="#LCP1-猜数字" class="headerlink" title="LCP1. 猜数字"></a>LCP1. <a href="https://leetcode-cn.com/problems/guess-numbers/">猜数字</a></h4><p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</p><p>示例 1：<br>输入：guess = [1,2,3], answer = [1,2,3]<br>输出：3<br>解释：小A 每次都猜对了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; guess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; answer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (guess[<span class="number">0</span>]==answer[<span class="number">0</span>])+(guess[<span class="number">1</span>]==answer[<span class="number">1</span>])+(guess[<span class="number">2</span>]==answer[<span class="number">2</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1295-统计位数为偶数的数字"><a href="#1295-统计位数为偶数的数字" class="headerlink" title="1295.  统计位数为偶数的数字"></a>1295.  <a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">统计位数为偶数的数字</a></h4><p>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。</p><p>示例 ：<br>输入：nums = [555,901,482,1771]<br>输出：1<br>解释：只有 1771 是位数为偶数的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = to_string(i); </span><br><span class="line">            <span class="keyword">if</span>(s.length() %<span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h4><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例:<br>输入: J = “aA”, S = “aAAbbbb”<br>输出: 3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> a = <span class="string">&quot;[^&quot;</span> + J + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="function">regex <span class="title">pattern</span><span class="params">(a)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> b = regex_replace(S, pattern, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> b.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//正则表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j : J)  &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> s : S)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s == j)</span><br><span class="line">                    num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//一般方法</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题收录</title>
      <link href="2020/01/18/%E5%BC%80%E5%8F%91/Linux/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2020/01/18/%E5%BC%80%E5%8F%91/Linux/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>面试题整理收录</strong>——软件工程师面试题收录，持续更新中…</p><a id="more"></a><h3 id="一、编程"><a href="#一、编程" class="headerlink" title="一、编程"></a>一、编程</h3><h4 id="1-gdb常用的命令"><a href="#1-gdb常用的命令" class="headerlink" title="1. gdb常用的命令"></a>1. <code>gdb</code>常用的命令</h4><p>编译的时候加上<code>-g</code>参数表示可以调试</p><p><code>l</code>:查看程序源码，默认10行<br><code>l 函数名</code>：将显示“函数名”所在函数的源代码<br><code>r</code>:运行<br><code>c</code>:继续运行到下一个断点处或者结束<br><code>n</code>:单步跟踪程序，当遇到函数调用时，也不进入此函数体<br><code>s</code>:单步调试如果有函数调用，则进入函数<br><code>until</code>:退出循环体<br><code>set args 参数</code>:指定运行时的参数<br><code>show args</code>:查看设置好的参数<br><code>call 函数(参数)</code>:调用程序中的可见程序<br><code>whatis</code>:查询变量或函数<br><code>b+函数名</code>:根据函数名设置断点<br><code>b+行号</code>:根据行号设置断点<br><code>info break</code>:查看断点列表<br><code>delete 断点号</code>:删除第几个断点<br><code>disable 断点号n</code>:暂停第n个断点<br><code>enable 断点号n</code>:开启第n个断点<br><code>delete breakpoints</code>:清除所有断点：<br><code>p 变量</code>:打印变量的值<br><code>p 函数(参数)</code>:调用函数，打印返回值<br><code>bt</code>:查看堆栈列表<br><code>quit</code>:退出调试</p><h4 id="2-C"><a href="#2-C" class="headerlink" title="2. C++"></a>2. C++</h4><ol><li><p>main函数前面是否需要加int或者void类型其实和编译器有关，默认不加是返回int类型的，有的编译器会有警告</p></li><li><p>对于<code>malloc</code>申请的内存空间，需要进行类型转换，malloc返回的是<code>void *</code>类型，free 后应将其指针赋为<code>NULL</code>,避免产生野指针</p></li><li><p><code>#ifndef</code>的最主要目的是防止头文件的重复包含和编译</p></li><li><p>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？</p><blockquote><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数</p></blockquote></li><li><p>C++中struct和class的区别</p><blockquote><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</p></blockquote></li><li><p>C++源文件从文本到可执行文件经历的过程</p><blockquote><ol><li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li><li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li><li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li><li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li></ol></blockquote></li><li><p>内存分配方式</p><blockquote><p>在C++中，内存分为：栈、堆(malloc)、自由存储区(new)、全局/静态存储区、常量存储区。</p></blockquote></li><li><p>p=NULL 的含义</p><blockquote><p>NULL的定义是这样的, <code>#define NULL ((void *)0)</code>,应用程序是不能访问0地址的，所以可以用0地址来表示一个空指针。</p></blockquote></li><li><p>内联函数的影响</p><blockquote><p>内联函数可能会使代码速度更快，也可能使速度变慢。可能会使可执行文件变大，也可能变小。可能会导致系统性能下降，也可能避免性能下降。内联函数可能（经常是）与速度完全无关</p></blockquote></li><li><p>引用和指针的区别</p><blockquote></blockquote></li><li><p>浮点数类型不能直接用等号比较</p></li><li><p>整型和浮点数类型相乘会自动转化为浮点数</p></li><li><p>求一个类的大小</p></li></ol><ul><li>空类的大小为 1</li><li>类中的成员函数不占用空间</li><li>类中的static修饰的成员变量不占空间</li><li>类中不管有几个（至少有一个）虚函数，会占用4个字节，因为会创建个虚表，类中首位置存放虚表的指针</li><li>继承类的大小就是基类的大小和本类的大小之和，但是如果本类有重写的或是继承的基类的虚函数，则都不会占用新空间，而是会在基类的虚表中覆盖和添加新的位置</li></ul><hr><h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><h4 id="1-有一个线程负责产生图像数据，有另外两个线程都需要使用这些数据，如何设计这样的数据结构？"><a href="#1-有一个线程负责产生图像数据，有另外两个线程都需要使用这些数据，如何设计这样的数据结构？" class="headerlink" title="1.有一个线程负责产生图像数据，有另外两个线程都需要使用这些数据，如何设计这样的数据结构？"></a>1.有一个线程负责产生图像数据，有另外两个线程都需要使用这些数据，如何设计这样的数据结构？</h4><p>此题中产生数据的线程可以成为生产者，而另外两个线程可以称为消费者，这就是典型的生产者消费者模型，为了保证数据的完整和功能的可靠，就需要对图像数据这块资源区进行保护，通常的做法是对其加锁，在写数据的时候不能读，但为了保证效率可以采用类似队列的数据结构，只要保证存在一帧完整的数据就可以被其他两个线程使用。</p><h3 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h3><h4 id="1-死锁是什么？死锁的原因有哪些？死锁的四个必要条件是什么？-如何解开死锁？"><a href="#1-死锁是什么？死锁的原因有哪些？死锁的四个必要条件是什么？-如何解开死锁？" class="headerlink" title="1.死锁是什么？死锁的原因有哪些？死锁的四个必要条件是什么？ 如何解开死锁？"></a>1.死锁是什么？死锁的原因有哪些？死锁的四个必要条件是什么？ 如何解开死锁？</h4><blockquote><p>死锁是指是指两个或两个以上的进程（线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，比如进程A需要获取进程B的锁，但进程B首先要得到进程A的锁才能释放自己的锁，但进程A还在阻塞在那里，无法释放它的锁，所以就陷入了僵局</p></blockquote><p>产生死锁的四个必要条件：<br>    （1） 互斥条件：一个资源每次只能被一个进程（线程）使用。<br>    （2） 请求与保持条件：一个进程（线程）因请求资源而阻塞时，对已获得的资源保持不放。<br>    （3） 不剥夺条件 : 此进程（线程）已获得的资源，在末使用完之前，不能强行剥夺。<br>    （4） 循环等待条件 : 多个进程（线程）之间形成一种头尾相接的循环等待资源关系。</p><p>如何避免死锁：<br>    （1）对于互斥，因为互斥不能破坏，所以不能由互斥入手来避免死锁<br>    （2）对于请求与保持，请求的时候先把自己的锁释放掉，然后再申请新的锁<br>    （3）对于循环等待，是一样的，在申请新锁的时候，先把自己的锁释放，在申请新锁，就不会陷入循环等待中<br>    （4）对于不剥夺，如果别人的锁的优先级比自己的锁的优先级高，则可以抢过来</p><h4 id="2-进程与线程的区别"><a href="#2-进程与线程的区别" class="headerlink" title="2.进程与线程的区别"></a>2.进程与线程的区别</h4><p><em>银行家算法</em></p><h4 id="2-计算下列程序一共有多少条进程"><a href="#2-计算下列程序一共有多少条进程" class="headerlink" title="2.计算下列程序一共有多少条进程?"></a>2.计算下列程序一共有多少条进程?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork();</span><br><span class="line">    fork() &amp;&amp; fork() || fork();</span><br><span class="line">    fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181108202723894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25hbl9sZWk=,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20181108202723894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25hbl9sZWk=,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,666" alt=""><br>子进程有10个，父进程有10个  共20个<br>(题源：<a href="https://blog.csdn.net/nan_lei/article/details/83867694">https://blog.csdn.net/nan_lei/article/details/83867694</a>)</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>OSI七层模型？TCP的四层模型？<br>OSI七层模型：从上层网下层依次是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<br>TCP四层模型：从上层网下层依次是应用层、传输层、网络层、数据链路和网络接口层</li><li>TCP、UDP的区别？<br>共同点：同为传输层协议<br>不同点：</li></ol><ul><li>TCP：有连接(通信前要进行三次握手)，可靠（保证四无原则：数据无误 无丢失 无失序 无重复到达）<br>适合于对传输质量要求较高，以及传输大量数据的通信。用户登录账户管理</li><li>UDP：无连接，不保证可靠<br>高效率的数据传输（实时性） 发送小尺寸数据  广播/组播  通讯软件的点对点文本通讯以及音视频通讯通常采用UDP协议</li></ul><p>待解答</p><ol><li><p>vector 或 map 的内部实现，各种操作的复杂度以及迭代器失效的可能场景<br>vector的数据安排以及操作方式，与array非常类似，两者唯一的区别是空间运用的灵活性，array是静态空间，一旦配置了就不能改变，如果你想要大一点的空间，就必须首先配置一块新空间，然后将原来的元素一一复制进来，再把原来的空间释放给系统。但是vector是动态空间，随着元素的增加，它的内部机制会自行扩充空间以容纳新元素，因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，vector动态增加大小时，并不是在原空间之后持续新空间而是以原大小的两倍另外配置一块较大的空间，然后将内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间，因此，一旦<code>引起空间重新配置，指向原vector的所有迭代器都失效了</code>。<br>map:Map是关联容器，以键值对的形式进行存储，方便进行查找，关键词起到索引的作用，值则表示与索引相关联的数据，以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成</p></li><li></li><li><p><code>shared_ptr</code> 的线程安全性、循环引用的后果及如何避免、weak_ptr 的作用<br>C++的特性：封装继承和多态<br>纯虚函数</p></li><li><p>内存对齐的原则</p></li><li><p>什么情况下需要将析构函数定义为虚函数？<br> 当基类指针指向派生类的对象（多态性）时。如果定义为虚函数，则就会先调用该指针指向的派生类析构函数，然后派生类的析构函数再又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。</p></li><li><p>C++中类与结构体的区别？<br>(1)最本质的一个区别就是默认的访问控制： struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。<br>(2)“class”这个关键字还用于定义模板参数</p></li><li><p>指针数组和数组指针，常量指针和指针常量，指针函数和函数指针；</p></li></ol><p><em>a[10] : 指针数组<br>(<em>a)[10] : 数组指针<br>int *fun() : 指针函数<br>int (</em>p)(int, int) : 函数指针<br>const char *a; 内容不可变，常量指针<br>char</em> const a; 地址不可变，指针常量<br>8. i++是否为原子操作？<br>在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。而<code>i++</code>是分三个阶段的，都可能被打断</p><ol start="10"><li>常用的设计模式<br>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点；定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br>工厂模式<h3 id="关于图像格式"><a href="#关于图像格式" class="headerlink" title="关于图像格式"></a>关于图像格式</h3></li></ol><p>YUV 4:4:4采样，每一个Y对应一组UV分量，图像和rgb占用的字小大小一致，均为pixelsize*3。<br>YUV 4:2:2采样，每两个Y共用一组UV分量，占用的大小为pixelsize+pixelsize/2+pixelsize/2。<br>YUV 4:2:0采样，每四个Y共用一组UV分量，占用大小为pixelsize+pixelsize/4+pixelsize/4</p><p>packed:打包格式是将yuv分量混合存在同一个数组中，yuv的存储先后不同，细分为了yuv、yvu、yvyu、uyvy等等<br>planar：平面格式是将yuv三个分量存成三个数组或者两个数组分别存储</p><p>常见的YUV格式列表：<br>I420: YYYYYYYY UU VV =&gt;YUV420P<br>YV12: YYYYYYYY VV UU =&gt;YUV420P<br>NV12: YYYYYYYY UVUV =&gt;YUV420SP<br>NV21: YYYYYYYY VUVU =&gt;YUV420SP</p><h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><h4 id="信号槽的用法"><a href="#信号槽的用法" class="headerlink" title="信号槽的用法"></a>信号槽的用法</h4><ol><li>一个信号可以和多个槽相连：这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的</li><li>多个信号可以连接到一个槽：只要任意一个信号发出，这个槽就会被调用</li><li>一个信号可以连接到另外的一个信号</li><li>槽可以被取消链接：对象被删除的时候</li></ol><h4 id="自定义信号槽需要注意的事项"><a href="#自定义信号槽需要注意的事项" class="headerlink" title="自定义信号槽需要注意的事项"></a>自定义信号槽需要注意的事项</h4><ul><li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</li><li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li><li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li><li>使用 emit 在恰当的位置发送信号；</li><li>使用QObject::connect()函数连接信号和槽。</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</li></ul><h4 id="Q-OBJECT的作用"><a href="#Q-OBJECT的作用" class="headerlink" title="Q_OBJECT的作用"></a>Q_OBJECT的作用</h4><blockquote><p>如果不加这一句代码，信号和槽函数的连接总是不成功</p></blockquote><h3 id="3-19-面试"><a href="#3-19-面试" class="headerlink" title="3.19 面试"></a>3.19 面试</h3><ol><li>QThread如何使用，线程的同步</li><li>QT串口编程使用的步骤</li><li>QT中的QSS</li><li>QT中的定时器使用</li><li>一个链表删除其中一个节点如何做</li><li>链表和数组的区别</li><li>指针与引用的区别</li><li>有类似二级指针一样的二级引用吗？</li><li>const与define的区别</li><li>为什么析构函数声明为虚函数</li><li>判断一个8位数的第四位为1</li><li>判断一个无符号数是否是奇数，不用%2</li><li>根据数据名求其元素个数</li><li>设计模式了解多少</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序容器</title>
      <link href="2020/01/16/%E5%BC%80%E5%8F%91/C++/C++/"/>
      <url>2020/01/16/%E5%BC%80%E5%8F%91/C++/C++/</url>
      
        <content type="html"><![CDATA[<p><strong>C++中的顺序容器操作</strong></p><a id="more"></a><h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="顺序容器的类型"><a href="#顺序容器的类型" class="headerlink" title="顺序容器的类型"></a>顺序容器的类型</h3><ul><li><code>vector</code>: 一般选用这个</li><li><code>deque</code>: 双端队列</li><li><code>list</code>: 双向链表</li><li><code>forward_list</code>: 单向链表</li><li><code>array</code>: 固定数组大小，不支持改变容器大小</li><li><code>string</code>: 与 vector 相似，专门保存字符</li></ul><h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="comment">//c1初始化为c2的拷贝</span></span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line">C c1 = c2;</span><br><span class="line"><span class="comment">//使用值进行初始化</span></span><br><span class="line">C c&#123;a, b, c...&#125;;</span><br><span class="line">C c = &#123;a, b, c...&#125;;</span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b, e)</span></span>;<span class="comment">//使用迭代器b-&gt;e范围元素初始化(类型必须兼容)</span></span><br><span class="line"><span class="comment">//顺序容器</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n)</span></span>;<span class="comment">//包含n个元素，这n个元素进行了值初始化</span></span><br><span class="line">Cseq(n, t);<span class="comment">//n个t进行初始化</span></span><br></pre></td></tr></table></figure><h3 id="容器赋值"><a href="#容器赋值" class="headerlink" title="容器赋值"></a>容器赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2;</span><br><span class="line">c = &#123;a, b, c...&#125;;</span><br><span class="line">swap(c1, c2);</span><br><span class="line">c1.swap(c2);</span><br><span class="line"><span class="comment">//assign操作不适用于array和关联容器</span></span><br><span class="line">seq.assign(b, e);<span class="comment">//迭代器b-&gt;e</span></span><br><span class="line">seq.assign(i1);<span class="comment">//使用i1列表初始化seq</span></span><br><span class="line">seq.assign(n, t);<span class="comment">//n个t</span></span><br></pre></td></tr></table></figure><h3 id="容器元素的插入"><a href="#容器元素的插入" class="headerlink" title="容器元素的插入"></a>容器元素的插入</h3><ul><li><code>forward_list</code>不支持<code>push_back</code>和<code>emplace_back</code></li><li><code>vector</code>和<code>string</code>不支持<code>push_front</code>和<code>emplace_front</code></li><li><code>emplace_front</code>、<code>emplace</code>和<code>emplace_back</code>这些操作是构造而不是拷贝元素，对应的是<code>push_front</code>、<code>insert</code>和<code>push_back</code>这些操作是拷贝元素到容器中而不是构造。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种是将对象放入容器</span></span><br><span class="line">c.emplace_back(<span class="string">&quot;223.23&quot;</span>, <span class="number">23</span>, <span class="number">45.6</span>);<span class="comment">//使用三个参数的Sales_data构造函数</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">&quot;223.23&quot;</span>, <span class="number">23</span>, <span class="number">45.6</span>));<span class="comment">//创建一个Sales_data对象放入c</span></span><br><span class="line">c.insert(iter, <span class="string">&quot;word&quot;</span>);<span class="comment">//将“word”插入到iter所指元素的之前位置，返回的是迭代器指向的这个新元素，emplace也是同理</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="容器元素的访问"><a href="#容器元素的访问" class="headerlink" title="容器元素的访问"></a>容器元素的访问</h3><ul><li><code>at</code>和下表操作只适用于<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code></li><li><code>back</code>不适用于<code>forward_list</code>。</li><li>使用迭代器注意：<code>end</code>指向容器尾元素之后的元素(不存在)，为了获取尾元素，需要将递减该迭代器<blockquote><p>在访问容器中的元素中容易出现访问越界的情况，应注意避免</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.back();<span class="comment">//返回c的尾元素</span></span><br><span class="line">c.front();<span class="comment">//返回c的首元素的引用</span></span><br><span class="line">c[n];<span class="comment">//返回c中下标为n的元素的引用</span></span><br><span class="line">c.at(n);<span class="comment">//返回c中下标为n的元素的引用</span></span><br></pre></td></tr></table></figure><h3 id="容器中元素的删除"><a href="#容器中元素的删除" class="headerlink" title="容器中元素的删除"></a>容器中元素的删除</h3>以下操作不适用于<code>array</code>, <code>forward_list</code>不支持<code>pop_back</code>;<code>vector</code>和<code>string</code>不支持<code>pop_front</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.pop_back();<span class="comment">//删除c的尾部元素</span></span><br><span class="line">c.pop_front();<span class="comment">//删除c的首部元素</span></span><br><span class="line">c.erase(p);<span class="comment">//删除迭代器p所指定的元素</span></span><br><span class="line">c.erase(b, e);<span class="comment">//删除迭代器b和e所指定的范围</span></span><br><span class="line">c.clear();<span class="comment">//删除c中所有的元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="迭代器失效情况"><a href="#迭代器失效情况" class="headerlink" title="迭代器失效情况"></a>迭代器失效情况</h3><p>向迭代器中添加元素和删除元素的代码可能会使迭代器失效，所以需要保证每次改变容器的大小之后重新定位迭代器，尤其是<code>vector</code>、<code>string</code>和<code>deque</code></p><ol><li>在循环中使用迭代器需要考虑迭代器失效的情况，需要保证在每一次循环都要更新迭代器、引用或指针</li><li><code>end</code>返回的迭代器不要保存，当容器中有发生元素增删都会使保存的迭代器失效，需要在插入或删除之后重新调用<code>end()</code>，不能再循环前保存</li></ol><h2 id="容器的容量"><a href="#容器的容量" class="headerlink" title="容器的容量"></a>容器的容量</h2><ul><li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li><li><code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code></li><li><code>reserve</code>不会改变容器中元素的个数，仅影响<code>vector</code>预先分配的内存空间大小，只有当需要的内存空间超过当前容量时，<code>reserve</code>函数才会被调用</li><li><code>size()</code>是当前容器中元素的数量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.shrink_to_fit();<span class="comment">//将capacity()减小为与size()相同大小</span></span><br><span class="line">c.capacity();<span class="comment">//不重新分配内存的话，c可以保存多少元素</span></span><br><span class="line">c.reserve();<span class="comment">//分配至少能容纳n个元素的内存空间</span></span><br></pre></td></tr></table></figure><h2 id="string的额外操作"><a href="#string的额外操作" class="headerlink" title="string的额外操作"></a>string的额外操作</h2></li></ul><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp, n)</span></span>;<span class="comment">//cp指向的数组的前n个字符的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2)</span></span>;<span class="comment">//从s2的下标pos2位置开始数据的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2, len)</span></span>;<span class="comment">//长度位len</span></span><br><span class="line">s.substr(p1, p2);<span class="comment">//字串，从下标p1位置到p2位置</span></span><br></pre></td></tr></table></figure><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入删除</span></span><br><span class="line">s.insert(pos, args);<span class="comment">//在pos之前插入args，pos可以是下标也可以是迭代器</span></span><br><span class="line">s.erase(pos, len);<span class="comment">//pos位置删除长度位len的字符</span></span><br><span class="line">s.assign(args);<span class="comment">//将s中的字符替换为args指定的字符</span></span><br><span class="line">s.append(args);<span class="comment">//将args追加到s</span></span><br><span class="line">s.replace(range, args);<span class="comment">//替换range范围内的字符为args指定的字符</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">s.find(args);<span class="comment">//查找args第一次出现的地方</span></span><br><span class="line">s.sfind(args);<span class="comment">//查找args最后一次出现的地方</span></span><br><span class="line">s.find_first_of(args);<span class="comment">//查找args中任何一个字符第一次出现的地方</span></span><br><span class="line">s.find_last_of(args);<span class="comment">//查找args中任何一个字符最后一次出现的地方</span></span><br><span class="line">s.find_first_not_of(args);<span class="comment">//查找s中第一个不在args中的字符</span></span><br><span class="line">s.find_last_not_of(args);<span class="comment">//查找s中最后一个不在args中的字符</span></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line">s.compare();<span class="comment">//参数可以有地址，长度和其它字符串，和strcmp很类似，返回值也一样</span></span><br><span class="line"><span class="comment">//数值转化</span></span><br><span class="line">to_string(val);<span class="comment">//将val转换为string类型</span></span><br><span class="line">stoi();<span class="comment">//int</span></span><br><span class="line">stol();<span class="comment">//long</span></span><br><span class="line">stoul();<span class="comment">//unsigned long</span></span><br><span class="line">stoll();<span class="comment">//long long</span></span><br><span class="line">stoull();<span class="comment">//unsigned long long</span></span><br><span class="line">stof();<span class="comment">//float</span></span><br><span class="line">stod();<span class="comment">//double</span></span><br><span class="line">stold();<span class="comment">//unsigned double</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程间通信</title>
      <link href="2020/01/16/%E5%BC%80%E5%8F%91/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>2020/01/16/%E5%BC%80%E5%8F%91/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<!-- **Linux进程间通信** --><a id="more"></a><h2 id="进程的操作"><a href="#进程的操作" class="headerlink" title="进程的操作"></a>进程的操作</h2><p>在 Linux 中最主要的进程标识有进程号(PID)和它的父进程号(PPID)，其中 PID 惟一地标识一个进程。在 Linux 中获得当前进程的 PID 和 PPID 的系统调用函数为 <code>getpid()</code> 和 <code>getppid()</code></p><p>进程根据它的生命周期可以分为三种状态:</p><ul><li>执行态：该进程正在运行，正在占用 CPU。</li><li>就绪态：进程已经具备执行的一切条件，正在等待分配 CPU 的处理时间片。</li><li>等待态：进程不能使用 CPU，若等待事件发生（等待的资源分配到）则可将其唤醒。</li></ul><p>转换关系如下图:</p><p>Linux 中的进程包含 3 个段，分别为“数据段”、“代码段”和“堆栈段”。</p><ul><li>数据段：存放的是全局变量、常量以及动态分配的空间。又分为普通数据段、静态初始化的全局变量、BSS 数据段（存放未初始化的全局变量）和堆（存放动态分配的数据）</li><li>代码段：存放的是程序代码的数据</li><li>堆栈段：存放的是子程序的返回地址、子程序的参数以及程序的局部变量</li></ul><p>进程结构示意图如下：</p><p>在 Linux 系统中，进程的执行模式划分为用户模式和内核模式。如果当前运行的是用户程序、应用程序或者内核之外的系统程序，那么对应进程就在用户模式下运行；如果在用户程序执行过程中出现系统调用或者发生中断事件，那么就要运行操作系统（即核心）程序，进程模式就变成内核模式。在内核模式下运行的进程可以执行机器的特权指令，而且此时该进程的运行不受用户的干扰，即使是 root 用户也不能干扰内核模式下进程的运。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间通信分为UNIX进程间通信（管道、信号），System V进程间通信（消息队列，信号量，共享内存），Posix 进程间通信（Posix 消息队列、 Posix 信号量以及 Posix 共享内存）</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>无名管道：可用在具有亲缘关系进程间的通信,在使用过程中需要将父进程的写端<code>fd[1]</code>和子进程的读端 <code>fd[0]</code> 关闭。</p><p>有名管道：除具有无名管道所具有的功能外还允许无亲缘关系进程间的通信。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建一个无名管道</span></span><br><span class="line"><span class="comment">参数：操作管道的文件描述符，fd[0]表示读端，fd[1]表示写端。</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建一个有名管道</span></span><br><span class="line"><span class="comment">参数：pathname：有名管道的路径名</span></span><br><span class="line"><span class="comment">      mode：权限，八进制数表示</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>在软件层次上对中断机制的一种模拟，用于通知进程有某事件发生.</p><p>常用的API:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：发送一个信号</span></span><br><span class="line"><span class="comment">参数：pid：发送的目标进程</span></span><br><span class="line"><span class="comment">     sig：发送的信号名称</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：向调用进程发送一个信号</span></span><br><span class="line"><span class="comment">参数：sig:信号的种类</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回非0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：定时发送SIGALRM信号</span></span><br><span class="line"><span class="comment">参数：定时的秒数</span></span><br><span class="line"><span class="comment">返回值：如果首次调用alarm，那么返回0；否则返回上一个alarm函数所剩余的时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">功能：将进程挂起接收任意一个信号；</span></span></span><br><span class="line"><span class="function"><span class="comment">参数：无</span></span></span><br><span class="line"><span class="function"><span class="comment">返回值：捕捉到信号或者信号处理函数返回时，返回-1；</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">void (*signal(int signum, void (*handler)(int)))(int));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：自定义对信号的处理</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment"> signum：需要设定信号的名字</span></span><br><span class="line"><span class="comment"> SIG_IGN 为忽略该信号</span></span><br><span class="line"><span class="comment"> SIG_DFL 采用默认方式处理信号</span></span><br><span class="line"><span class="comment"> handler：一个函数指针，指向一个返回值为void，参数为int型的这么一个函数；</span></span><br><span class="line"><span class="comment">返回值：返回handler函数的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="实验例程"><a href="#实验例程" class="headerlink" title="实验例程"></a>实验例程</h4><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。<br>消息队列可以按照类型来发送/接收消息。</p><blockquote><p>消息队列操作的过程：获得key值，创建或打开一个消息队列，向消息队列中发送/接受消息，对消息队列进行操作</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建或打开一个消息队列</span></span><br><span class="line"><span class="comment">参数：key：ftok返回值或者是IPC_PRIVATE        </span></span><br><span class="line"><span class="comment">     msgflg：八进制权限</span></span><br><span class="line"><span class="comment">返回值：成功返回msgid，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：向消息队列中发送消息</span></span><br><span class="line"><span class="comment">参数：msgid：消息队列的ID</span></span><br><span class="line"><span class="comment">      msgp：存放消息的结构体指针</span></span><br><span class="line"><span class="comment">      msgsz：消息正文的大小</span></span><br><span class="line"><span class="comment">      msgflg：设为0则直到发送完成函数才返回，IPC_NOWAIT  消息没有发送完成函数也会立即返回。</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：从消息队列中读取指定类型的消息</span></span><br><span class="line"><span class="comment">参数：msgid：消息队列的ID</span></span><br><span class="line"><span class="comment">      msgp：存放消息的结构体指针</span></span><br><span class="line"><span class="comment">      msgsz：消息正文的大小</span></span><br><span class="line"><span class="comment">      msgtyp：消息的类型</span></span><br><span class="line"><span class="comment">      msgflg：0：若无消息函数会一直阻塞，IPC_NOWAIT：若没有消息，进程会立即返回ENOMSG。</span></span><br><span class="line"><span class="comment">返回值：成功返回读取到的消息长度，失败返回-1</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">      struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">            long mtype;       // message type, must be &gt; 0 </span></span><br><span class="line"><span class="comment">            char mtext[1];    // message data </span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span> <span class="params">( <span class="keyword">int</span> msgqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf )</span></span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：对消息队列进行操作</span></span><br><span class="line"><span class="comment">参数：msgqid：消息队列的ID</span></span><br><span class="line"><span class="comment">      cmd： IPC_STAT表示获取消息队列的信息</span></span><br><span class="line"><span class="comment">            IPC_SET表示设置消息队列的信息</span></span><br><span class="line"><span class="comment">            IPC_RMID表示删除消息队列</span></span><br><span class="line"><span class="comment">     buf ：消息队列缓冲区</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="实验例程-1"><a href="#实验例程-1" class="headerlink" title="实验例程"></a>实验例程</h4><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是一种最为高效的进程间通信方式。因为进程可以直接读写内存，不需要任何数据的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进程将其映射到自己的私有地址空间。需要锁或者信号量来做同步。</p><blockquote><p>使用共享内存顺序：获取key值,创建或打开一段共享内存，映射/撤销映射共享内存，对共享内存进行操作</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：指定一文件，获得一个key值</span></span><br><span class="line"><span class="comment">参数：pathname：文件名</span></span><br><span class="line"><span class="comment">      proj_id：密码八位，通常用一个字符表示，一个字符八位</span></span><br><span class="line"><span class="comment">返回值：成功返回一个key值，失败返回-1；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建或打开一段共享内存</span></span><br><span class="line"><span class="comment">参数：key：ftok函数返回值或者IPC_PRIVATE，如果是private，每个申请共享内存的进程都会获得一块共享内存，而不会因为存在而不会创建</span></span><br><span class="line"><span class="comment">    size：申请共享内存的大小</span></span><br><span class="line"><span class="comment">    shmflg：打开方式及权限 IPC_CREAT  IPC_EXCL</span></span><br><span class="line"><span class="comment">返回值：成功返回创建的共享内存的shmid，失败返回-1并且设置errno,一般需要对其返回值判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：映射共享内存</span></span><br><span class="line"><span class="comment">参数：shmid：共享内存ID</span></span><br><span class="line"><span class="comment">     shmaddr：一般设为NULL，否则需要自定义映射地址</span></span><br><span class="line"><span class="comment">     shmflg：SHM_RDONLY为只读，0表示可读可写</span></span><br><span class="line"><span class="comment">返回值：成功返回映射后的地址，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：取消映射共享内存</span></span><br><span class="line"><span class="comment">参数：取消映射的地址</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：对共享内存进行操作</span></span><br><span class="line"><span class="comment">参数：shmid：共享内存的ID</span></span><br><span class="line"><span class="comment">     cmd：IPC_STAT表示获取共享内存的信息</span></span><br><span class="line"><span class="comment">          IPC_SET表示设置共享内存的信息</span></span><br><span class="line"><span class="comment">          IPC_RMID表示删除共享内存</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="实验例程："><a href="#实验例程：" class="headerlink" title="实验例程："></a>实验例程：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来解决进程之间的同步与互斥问题的一种进程之间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（PV 操作）。其中信号量对应于某一种资源，取一个非负的整型值。信号量值指的是当前可用的该资源的数量，若它等于 0 则意味着目前没有可用的资源。<br>P操作：（信号量值减一）如果有可用的资源（信号量值&gt;0），则占用一个资源，进入临界区<br>V 操作：（给信号量值加一）如果在该信号量的等待队列中有进程在等待资源，则可以唤醒一个阻塞进程。如果没有进程等待它，则释放一个资源。</p><p>在 Linux 系统中，使用信号量通常分为以下几个步骤：<br>（1）创建信号量或获得在系统已存在的信号量，此时需要调用 <code>semget()</code>函数。不同进程通过使用同一个信号量键值来获得同一个信号量。<br>（2）初始化信号量，此时使用 <code>semctl()</code>函数的 <code>SETVAL</code> 操作。当使用二维信号量时，通常将信号量初始化为 1。<br>（3）进行信号量的 PV 操作，此时调用 <code>semop()</code>函数。这一步是实现进程之间的同步和互斥的核心工作部分。<br>（4）如果不需要信号量，则从系统中删除它，此时使用 <code>semclt()</code>函数的 <code>IPC_RMID</code> 操作。此时需要注意，在程序中不应该出现对已经被删除的信号量的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    key, ftok()返回值</span></span><br><span class="line"><span class="comment">    nsems, 指定的信号量集合中的信号量个数</span></span><br><span class="line"><span class="comment">    semflg, </span></span><br><span class="line"><span class="comment">           IPC_CREAT</span></span><br><span class="line"><span class="comment">           IPC_EXCL</span></span><br><span class="line"><span class="comment">返回值：返回该集合的标识符，失败-7， 1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：信号量集合的控制</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">     semid, 指定要操作的集合</span></span><br><span class="line"><span class="comment">     semnum, 要操作的信号量的编号，编号从0开始</span></span><br><span class="line"><span class="comment">     cmd：</span></span><br><span class="line"><span class="comment">         GETVAL：获取信号灯的值, 返回值是获得值。</span></span><br><span class="line"><span class="comment">         比如：value = semctl(semid, 0, GETVAL)；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">         SETVAL：设置信号灯的值，需要用到第四个参数。*/</span></span><br><span class="line">         第四个参数类型如下：         </span><br><span class="line">           <span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">                                           (Linux-specific) */</span></span><br><span class="line">           &#125;;</span><br><span class="line"> </span><br><span class="line">          比如：</span><br><span class="line">          <span class="class"><span class="keyword">union</span> <span class="title">semun</span>&#123;</span></span><br><span class="line">                <span class="keyword">int</span>  val;</span><br><span class="line">                &#125;;</span><br><span class="line">           <span class="class"><span class="keyword">union</span> <span class="title">semun</span>  <span class="title">mysenum</span>;</span></span><br><span class="line">           mysemum.val = <span class="number">10</span>;</span><br><span class="line">           semctl(semid, <span class="number">0</span>, SETVAL,mysemnum);</span><br><span class="line"> </span><br><span class="line">         IPC_RMID：从系统中删除信号灯集合</span><br><span class="line">         比如： semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line"> </span><br><span class="line">返回值：和cmd有关，失败<span class="number">-1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span> <span class="params">( <span class="keyword">int</span> semid, struct sembuf  *opsptr,  <span class="keyword">unsigned</span>  nops)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：就是对信号量集合中的信号量进行PV操作</span><br><span class="line">参数： semid, </span><br><span class="line">       opsptr,</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num;  <span class="comment">/* semaphore number */</span></span><br><span class="line">           <span class="keyword">short</span>          sem_op;   <span class="comment">/* semaphore operation */</span></span><br><span class="line">           <span class="keyword">short</span>          sem_flg;  <span class="comment">/* operation flags */</span></span><br><span class="line">         &#125;;</span><br><span class="line">         成员分析：</span><br><span class="line">         sem_num 表示要操作的信号量的编号</span><br><span class="line">         sem_op, 表示进行P或者V操作， 比如：sem_op = <span class="number">10</span>(+<span class="number">10</span>)</span><br><span class="line">                                            sem_op = <span class="number">-10</span>(<span class="number">-10</span>)</span><br><span class="line">                                            sem_op = <span class="number">0</span>, 那么semop函数会等到该信号量的值变为<span class="number">0</span>为止。</span><br><span class="line">         sem_flg,</span><br><span class="line">                 <span class="number">0</span>(最常用的)，表示semop函数的操作是阻塞的，直到成功为止。</span><br><span class="line">                 IPC_NOWAIT，表示semop函数的操作是非阻塞的，如果操作没有成功，立刻返回。</span><br><span class="line">                 SEM_UNDO（不常用），设置只对当前进程有效，不会保存到系统的信号量集合中。</span><br><span class="line">      </span><br><span class="line">         nops, 调用一次semop要操作的信号量的个数</span><br><span class="line"> </span><br><span class="line">返回值：成功<span class="number">0</span>， 失败<span class="number">-1</span>  </span><br><span class="line">程序如下：实现功能，运行一次一个信号量进行+<span class="number">5</span>操作，另一个信号量<span class="number">-5</span>操作，等到信号量减为<span class="number">0</span>时，阻塞 </span><br></pre></td></tr></table></figure><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>可用于网络中不同机器之间的进程间通信，具体内容会在<code>socket</code>网络编程说明</p><h2 id="各种进程间通信方式的对比"><a href="#各种进程间通信方式的对比" class="headerlink" title="各种进程间通信方式的对比"></a>各种进程间通信方式的对比</h2><p>如图所示：<br><img src="/assets/blog/Linux/%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94.PNG" class="lazyload" data-srcset="/assets/blog/Linux/%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94.PNG" srcset="data:image/png;base64,666" alt="进程间通信对比"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
