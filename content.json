{"meta":{"title":"CHARY | 哈哈哈哈哈","subtitle":"","description":"","author":"Chary","url":"http://CharyPro.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-12-04T15:41:48.160Z","updated":"2020-12-04T15:41:48.160Z","comments":true,"path":"404.html","permalink":"http://charypro.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-12-06T04:16:06.462Z","updated":"2020-12-06T04:16:06.462Z","comments":false,"path":"about/index.html","permalink":"http://charypro.github.io/about/index.html","excerpt":"","text":"欢迎来到我的博客 胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤"},{"title":"其它","date":"2020-12-04T15:41:48.193Z","updated":"2020-12-04T15:41:48.193Z","comments":true,"path":"else/index.html","permalink":"http://charypro.github.io/else/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-12-04T15:41:48.194Z","updated":"2020-12-04T15:41:48.194Z","comments":true,"path":"friends/index.html","permalink":"http://charypro.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-12-04T15:41:48.193Z","updated":"2020-12-04T15:41:48.193Z","comments":true,"path":"categories/index.html","permalink":"http://charypro.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-04T15:41:48.195Z","updated":"2020-12-04T15:41:48.195Z","comments":true,"path":"tags/index.html","permalink":"http://charypro.github.io/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-12-06T07:44:58.596Z","updated":"2020-12-06T07:44:58.596Z","comments":true,"path":"projects/index.html","permalink":"http://charypro.github.io/projects/index.html","excerpt":"","text":"关于我https://charypro.github.io/about/"}],"posts":[{"title":"新电脑重新搭建Blog","slug":"其它/新电脑重新搭建Blog","date":"2020-12-04T16:00:00.000Z","updated":"2020-12-04T16:00:00.000Z","comments":true,"path":"2020/12/05/其它/新电脑重新搭建Blog/","link":"","permalink":"http://charypro.github.io/2020/12/05/%E5%85%B6%E5%AE%83/%E6%96%B0%E7%94%B5%E8%84%91%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BABlog/","excerpt":"要点：在新的电脑上重新搭建自己的博客平台","text":"要点：在新的电脑上重新搭建自己的博客平台 下载安装Node.js https://nodejs.org/en/ 安装 hexo1npm install -g hexo-cli --registry=https://registry.npm.taobao.org 下载blog源代码 进入blog源码目录1npm install hexo-deployer-git --registry=https://registry.npm.taobao.org 正常使用1234hexo cleanhexo ghexo s # 测试hexo d","categories":[{"name":"Blog搭建","slug":"Blog搭建","permalink":"http://charypro.github.io/categories/Blog%E6%90%AD%E5%BB%BA/"}],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"道格拉斯算法的使用","slug":"开发/C++/Douglas-Peuker算法","date":"2020-06-21T16:00:00.000Z","updated":"2020-06-21T16:00:00.000Z","comments":true,"path":"2020/06/22/开发/C++/Douglas-Peuker算法/","link":"","permalink":"http://charypro.github.io/2020/06/22/%E5%BC%80%E5%8F%91/C++/Douglas-Peuker%E7%AE%97%E6%B3%95/","excerpt":"本篇文章内容： 道格拉斯算法的内容 算法的普通实现 在2D和3D空间中的实现","text":"本篇文章内容： 道格拉斯算法的内容 算法的普通实现 在2D和3D空间中的实现 道格拉斯算法的内容参考：道格拉斯算法-百度百科 道格拉斯 Douglas-Peuker 算法 的递归实现Largest Triangle Area 最大的三角区域 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;QPoint&gt;#include &lt;QVector&gt;/** * @brief CPointRarefyOprt::PerpendicularDistance 计算点到首尾连线间的距离(垂距) * @param Point1 首坐标 * @param Point2 尾坐标 * @param Point 要计算到直线距离的点 * @return */double PerpendicularDistance(const QPoint &amp;Point1, const QPoint &amp;Point2, const QPoint &amp;Point)&#123; //行列式算法的展开 double area = fabsf(0.5 * (Point1.x * Point2.y + Point2.x * Point.y + Point.x * Point1.y - Point2.x * Point1.y - Point.x * Point2.y - Point1.x * Point.y)); double bottom = sqrtf(pow(Point1.x - Point2.x, 2) + pow(Point1.y - Point2.y, 2)); double height = area / bottom * 2; return height;&#125;/** * @brief DouglasPeuckerReduction 道格拉斯——普克算法 * @param Points 要进行简化的曲线的点列 * @param startPoint 进行此算法的曲线开始的点的数组下标 * @param endPoint 进行此算法的曲线结束的点的数组下标 * @param tolerance 极差D(阈值) * @param resultPoints 得到的简化的曲线 */void DouglasPeuckerReduction(QVector&lt;QPoint&gt; Points,int startPoint ,int endPoint, double tolerance,QVector&lt;QPoint&gt; resultPoints)&#123; double maxDistance = 0; //最远距离(垂距) int indexFarthest = -1; //最远距离点的数组下标 if(endPoint-startPoint&lt;=1) &#123; if(endPoint==startPoint) &#123; //endPoint==startPoint相等时，只有一个点时，所以添加一个点 resultPoints.append(points[startPoint]); &#125; else &#123; //有两个点时，添加两个点 resultPoints.append(points[startPoint]); resultPoints.append(points[endPoint]); &#125; //当小于等于两个点时，直接返回 return; &#125; for (int index = startPoint; index &lt; endPoint; index++) &#123; double distance = PerpendicularDistance(points[startPoint],points[endPoint],points[index]); if (distance &gt; maxDistance) &#123; //当新得到的点的垂距大于之前的最大垂距时，更新最大垂距，并且更新最大垂距点的下标 maxDistance = distance; indexFarthest = index; &#125; &#125; if (maxDistance &gt; tolerance &amp;&amp; indexFarthest != -1) &#123; //对起始点到最大垂距点之间的点重复进行道格拉斯——普克算法 DouglasPeuckerReduction(points, startPoint,indexFarthest-1, tolerance, resultPoints); //将最大垂距点保留 resultPoints.append(points[indexFarthest]); //对最大垂距点到结束点之间的点重复进行道格拉斯——普克算法 DouglasPeuckerReduction(points, indexFarthest+1,endPoint, tolerance, resultPoints); &#125; return;&#125; 道格拉斯算法在点云简化中的实现参考LineSimplification的代码，包括2D和3D点中算法的应用网盘备份地址：链接：https://pan.baidu.com/s/1PqmIGwZJUrq7djdspOZJ3w 提取码：6cut","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"开发/算法","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://charypro.github.io/tags/C/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"QGLViewer库的使用（更新...）","slug":"开发/QT/QGLViewer的使用","date":"2020-06-21T16:00:00.000Z","updated":"2020-06-21T16:00:00.000Z","comments":true,"path":"2020/06/22/开发/QT/QGLViewer的使用/","link":"","permalink":"http://charypro.github.io/2020/06/22/%E5%BC%80%E5%8F%91/QT/QGLViewer%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"本篇文章内容： QGLViewer环境的搭建 下次更新","text":"本篇文章内容： QGLViewer环境的搭建 下次更新 QGLViewer 的安装参考官网的教程基本都可以编译成功，我用QT编译的时候出现“无法打开../../QGLViewer.lib”我还以为是失败了，后来用VS中的QT插件打开编译，没有抱任何问题。（注意选对平台和版本）。编译完成后将QGLViewer2.lib和QGLViewer2.dll还有头文件都可以拷出去形成自己的最终的库，方便其他工程使用。 关于QGLViewer的cmake工程 首先是 QGLViewerConfig.cmake（来源CGAL中的FindQGLViewer.cmake） 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# - Try to find QGLViewer# Once done this will define## QGLVIEWER_FOUND - system has QGLViewer# QGLVIEWER_INCLUDE_DIR - the QGLViewer include directory# QGLVIEWER_LIBRARIES - Link these to use QGLViewer# QGLVIEWER_DEFINITIONS - Compiler switches required for using QGLViewer#if(POLICY CMP0072) # About the use of OpenGL cmake_policy(SET CMP0072 NEW)endif()find_package(OpenGL QUIET)find_package(Qt5 QUIET COMPONENTS OpenGL Xml)# first look in user defined locationsfind_path(QGLVIEWER_INCLUDE_DIR NAMES QGLViewer/qglviewer.h NO_DEFAULT_PATH PATHS ENV QGLVIEWERROOT /usr/local/include )find_library(QGLVIEWER_LIBRARY_RELEASE NAMES qglviewer-qt5 qglviewer QGLViewer-qt5 QGLViewer QGLViewer2-qt5 QGLViewer2 NO_DEFAULT_PATH PATHS ENV QGLVIEWERROOT ENV LD_LIBRARY_PATH ENV LIBRARY_PATH /usr/local/lib PATH_SUFFIXES QGLViewer QGLViewer/release )find_library(QGLVIEWER_LIBRARY_DEBUG NAMES dqglviewer dQGLViewer-qt5 dQGLViewer dQGLViewer2-qt5 dQGLViewer2 QGLViewerd2-qt5 QGLViewerd2 NO_DEFAULT_PATH PATHS /usr/local/lib ENV QGLVIEWERROOT ENV LD_LIBRARY_PATH ENV LIBRARY_PATH PATH_SUFFIXES QGLViewer QGLViewer/debug )#now try the standard pathsif (NOT QGLVIEWER_INCLUDE_DIR OR NOT QGLVIEWER_LIBRARY_RELEASE OR NOT QGLVIEWER_LIBRARY_DEBUG)find_path(QGLVIEWER_INCLUDE_DIR NAMES QGLViewer/qglviewer.h)find_library(QGLVIEWER_LIBRARY_RELEASE NAMES qglviewer-qt5 qglviewer QGLViewer-qt5 QGLViewer QGLViewer2-qt5 QGLViewer2)find_library(QGLVIEWER_LIBRARY_DEBUG NAMES dqglviewer dQGLViewer-qt5 dQGLViewer dQGLViewer2-qt5 dQGLViewer2 QGLViewerd2-qt5 QGLViewerd2)endif()if(QGLVIEWER_LIBRARY_RELEASE) if(QGLVIEWER_LIBRARY_DEBUG) set(QGLVIEWER_LIBRARIES_ Qt5::Xml Qt5::OpenGL $&#123;OPENGL_LIBRARIES&#125; optimized $&#123;QGLVIEWER_LIBRARY_RELEASE&#125; debug $&#123;QGLVIEWER_LIBRARY_DEBUG&#125;) else() set(QGLVIEWER_LIBRARIES_ Qt5::Xml Qt5::OpenGL $&#123;OPENGL_LIBRARIES&#125; $&#123;QGLVIEWER_LIBRARY_RELEASE&#125;) endif() set(QGLVIEWER_LIBRARIES $&#123;QGLVIEWER_LIBRARIES_&#125; CACHE FILEPATH &quot;The QGLViewer library&quot;)endif()IF(QGLVIEWER_INCLUDE_DIR AND QGLVIEWER_LIBRARIES) SET(QGLVIEWER_FOUND TRUE)ENDIF(QGLVIEWER_INCLUDE_DIR AND QGLVIEWER_LIBRARIES)IF(QGLVIEWER_FOUND) IF(NOT QGLViewer_FIND_QUIETLY) MESSAGE(STATUS &quot;Found QGLViewer: $&#123;QGLVIEWER_LIBRARIES&#125;&quot;) ENDIF(NOT QGLViewer_FIND_QUIETLY)ELSE(QGLVIEWER_FOUND) IF(QGLViewer_FIND_REQUIRED) MESSAGE(FATAL_ERROR &quot;Could not find QGLViewer&quot;) ENDIF(QGLViewer_FIND_REQUIRED)ENDIF(QGLVIEWER_FOUND) CMakeListx.txt的简单示例 点击查看代码 1234567cmake_minimum_required(VERSION 3.8 FATAL_ERROR)project(QGLViewer_Test)find_package(QGLViewer REQUIRED)message(STATUS &quot;$&#123;QGLVIEWER_INCLUDE_DIR&#125; $&#123;QGLVIEWER_LIBRARIES&#125;&quot;)include_directories(../include $&#123;QGLVIEWER_INCLUDE_DIR&#125;)add_executable(QGLViewer_Test main.cpp simpleViewer.cpp)target_link_libraries(QGLViewer_Test $&#123;QGLVIEWER_LIBRARIES&#125;)","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"QT","slug":"开发/QT","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/QT/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://charypro.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://charypro.github.io/tags/QT/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"Github开源人脸识别项目face_recognition","slug":"项目/人脸识别","date":"2020-06-14T16:00:00.000Z","updated":"2020-06-14T16:00:00.000Z","comments":true,"path":"2020/06/15/项目/人脸识别/","link":"","permalink":"http://charypro.github.io/2020/06/15/%E9%A1%B9%E7%9B%AE/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/","excerpt":"功能介绍： 从图片中定位人脸 识别人脸关键点 人脸识别人物 …","text":"功能介绍： 从图片中定位人脸 识别人脸关键点 人脸识别人物 … 参考：https://zhuanlan.zhihu.com/p/45827914 安装1.编译dlib库12345git clone https://github.com/davisking/dlib.gitcd dlibmkdir build; cd build; cmake ..; cmake --build .cd ..python3 setup.py install 安装后，可以在python中import dlib测试是否成功 安装 face_recognition123pip3 install face_recognition #下载太慢#可能需要这样做pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple face_recognition 功能测试face_detection 和 face_recognition命令行Python代码中测试","categories":[],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"QT动画操作","slug":"开发/QT/QT动画操作","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-10T16:00:00.000Z","comments":true,"path":"2020/05/11/开发/QT/QT动画操作/","link":"","permalink":"http://charypro.github.io/2020/05/11/%E5%BC%80%E5%8F%91/QT/QT%E5%8A%A8%E7%94%BB%E6%93%8D%E4%BD%9C/","excerpt":"本篇文章主要内容： QT的动画实现","text":"本篇文章主要内容： QT的动画实现 动画框架基础由基类QAbstractAnimation以及它的两个子类QVariantAnimation、QAnimationGroup组成。 QT动画属性QPropertyAnimation类能够修改Qt属性值示例如下，将button在10秒的持续时间从屏幕的左上角移动到(250, 250)点处。从开始位置到结束位置之间时间是均匀分配的，可以称为是线性的 点击查看代码 123456789QPushButton button(&quot;Button&quot;);button.show();QPropertyAnimation animation(&amp;button, &quot;geometry&quot;);animation.setDuration(10000);animation.setStartValue(QRect(0, 0, 100, 30));animation.setEndValue(QRect(250, 250, 100, 30));animation.start(); 另一种持续时间非均匀变化的例子如下，在前8秒移动到一个位置，在后2秒移动到原来位置 点击查看代码 1234567891011QPushButton button(&quot;Button&quot;);button.show();QPropertyAnimation animation(&amp;button, &quot;geometry&quot;);animation.setDuration(10000);animation.setKeyValueAt(0, QRect(0, 0, 100, 30));animation.setKeyValueAt(0.8, QRect(250, 250, 100, 30));animation.setKeyValueAt(1, QRect(0, 0, 100, 30));animation.start(); 对于没有声明动画属性的QObject对象中，动画操作其中的值时，需要为该值设置个能进行修改的函数。所以可以进行子类化，在该类中包含声明属性的值并且有个设置函数。每个Qt属性需要一个获取值的访问函数，因此如果类本身没提供对该值的访问函数的话，你自己就需要提供一个。如下代码例子中，我们子类化QGraphicsRectItem类，并且定义了”geometry”属性。即使QGraphicsRectItem没有提供”geometry”属性，我们也可以动画操作MyGraphicsRectItem的位置信息了。 点击查看代码 12345class MyGraphicsRectItem : public QObject, public QGraphicsRectItem&#123; Q_OBJECT Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)&#125;; 缓和曲线 点击查看代码 1234567891011QPushButton button(&quot;Animated Button&quot;);button.show();QPropertyAnimation animation(&amp;button, &quot;geometry&quot;);animation.setDuration(3000);animation.setStartValue(QRect(0, 0, 100, 30));animation.setEndValue(QRect(250, 250, 100, 30));animation.setEasingCurve(QEasingCurve::OutBounce);//设置缓和曲线animation.start(); 以上的例子中，动画沿着OutBounce曲线，该曲线样式是到结束处会弹跳起来像个弹跳球。QEasingCurve类有大量供选择的曲线，它们被定义成QEasingCurve::Type枚举。如果你需要另外的曲线样式，也可以自己实现一个，然后用QEasingCurve注册它既可。 动画分组动画分组主要分为两种，并行(QParallelAnimationGroup)和串行(QSequentialAnimationGroup) 并行分组动画组内动画可以同时进行，示例如下 点击查看代码 12345678910111213141516171819202122QPushButton *bonnie = new QPushButton(&quot;Bonnie&quot;);bonnie-&gt;show();QPushButton *clyde = new QPushButton(&quot;Clyde&quot;);clyde-&gt;show();// 动画一QPropertyAnimation *anim1 = new QPropertyAnimation(bonnie, &quot;geometry&quot;);anim1-&gt;setDuration(3000);anim1-&gt;setStartValue(QRect(0, 0, 100, 30));anim1-&gt;setEndValue(QRect(500, 500, 100, 30));// 动画二QPropertyAnimation *anim2 = new QPropertyAnimation(clyde, &quot;geometry&quot;);anim2-&gt;setDuration(3000);anim2-&gt;setStartValue(QRect(500, 500, 100, 30));anim2-&gt;setEndValue(QRect(1000, 500, 100, 30));QParallelAnimationGroup *group = new QParallelAnimationGroup;group-&gt;addAnimation(anim1);group-&gt;addAnimation(anim2);group-&gt;start(); 串行分组动画组内动画按一定顺序执行，示例如下： 点击查看代码 12345678910111213141516171819QPushButton button(&quot;Animated Button&quot;);button.show();QPropertyAnimation anim1(&amp;button, &quot;geometry&quot;);anim1.setDuration(3000);anim1.setStartValue(QRect(0, 0, 100, 30));anim1.setEndValue(QRect(500, 500, 100, 30));QPropertyAnimation anim2(&amp;button, &quot;geometry&quot;);anim2.setDuration(3000);anim2.setStartValue(QRect(500, 500, 100, 30));anim2.setEndValue(QRect(1000, 500, 100, 30));QSequentialAnimationGroup group;group.addAnimation(&amp;anim1);group.addAnimation(&amp;anim2);group.start(); 动画状态机使用状态机时，我们可以使用QSignalTransition或QEventTransition类将一个或者多个动画与状态之间的切换中进行关联。这些类继承于QAbstractTransition，QAbstractTransition类提供了函数addAnimation()，该函数在状态切换发生的情况下能触发一个或多个被附加的动画。以下示例实现了，点击按钮会移动到一个位置，再点击按钮又会回到原来的位置 点击查看代码 12345678910111213141516171819202122232425QPushButton *button = new QPushButton(&quot;Animated Button&quot;);button-&gt;show();QStateMachine *machine = new QStateMachine;//创建状态机//第一种状态时按钮的位置QState *state1 = new QState(machine);state1-&gt;assignProperty(button, &quot;geometry&quot;, QRect(0, 0, 100, 30));machine-&gt;setInitialState(state1);//第二种状态时按钮的位置QState *state2 = new QState(machine);state2-&gt;assignProperty(button, &quot;geometry&quot;, QRect(250, 250, 100, 30));//当点击按钮时会触发第二种状态QSignalTransition *transition1 = state1-&gt;addTransition(button, SIGNAL(clicked()), state2);transition1-&gt;addAnimation(new QPropertyAnimation(button, &quot;geometry&quot;));//当点击按钮时会触发第一种状态QSignalTransition *transition2 = state2-&gt;addTransition(button, SIGNAL(clicked()), state1);transition2-&gt;addAnimation(new QPropertyAnimation(button, &quot;geometry&quot;));machine-&gt;start();","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"QT","slug":"开发/QT","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/QT/"}],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"新版本Blog主题写作指南","slug":"其它/新版Blog写作指南","date":"2020-04-24T16:00:00.000Z","updated":"2020-04-24T16:00:00.000Z","comments":true,"path":"2020/04/25/其它/新版Blog写作指南/","link":"","permalink":"http://charypro.github.io/2020/04/25/%E5%85%B6%E5%AE%83/%E6%96%B0%E7%89%88Blog%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/","excerpt":"今天更新了之前用的Blog主题，现在是最新的2.0版本 —— Volantis,此版本中更新了不少的功能，在此将常用的一些操作记录下来，以便今后查询 Volantis 更多新功能请点击","text":"今天更新了之前用的Blog主题，现在是最新的2.0版本 —— Volantis,此版本中更新了不少的功能，在此将常用的一些操作记录下来，以便今后查询 Volantis 更多新功能请点击 文本和段落在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 Volantis A Wonderful Theme for Hexo 为简单的一句话提供的简便写法。 支持同样丰富的参数。 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 按钮基础按钮不设置任何参数的 按钮 适合融入段落中。 regular 按钮适合独立于段落之外： 示例博客 large 按钮更具有强调作用，建议搭配 center 使用： 开始使用 富文本按钮 下载源码 查看文档 xaoxuu xaoxuu xaoxuu 下拉菜单 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 折叠 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 1#include &lt;iostream&gt; 查看列表测试 hahahehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha 多媒体Image添加描述： 指定宽度： 指定宽度并添加描述： VideoYour browser does not support the video tag. 数学公式注意要在文章开头添加 mathjax: true $t+1=2$ $$\\mbox{积累因子}=\\begin{cases}1+ni &amp; \\mbox{单利}\\\\(1+i)^n &amp; \\mbox{复利}\\end{cases}$$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$ 代码块高亮显示12345678n=eval(input())if n==0: print(&quot;Hello World&quot;)elif n&gt;0: print(&quot;He\\nll\\no \\nWo\\nrl\\nd&quot;)else: for c in &quot;Hello World&quot;: print(c)","categories":[],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"牛客网错题收录","slug":"开发/C++/牛客网错题","date":"2020-03-17T16:00:00.000Z","updated":"2020-03-17T16:00:00.000Z","comments":true,"path":"2020/03/18/开发/C++/牛客网错题/","link":"","permalink":"http://charypro.github.io/2020/03/18/%E5%BC%80%E5%8F%91/C++/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98/","excerpt":"牛客网错题整理收录——软件工程师面试题收录，持续更新中…","text":"牛客网错题整理收录——软件工程师面试题收录，持续更新中… 基础知识 在C++中常量可分为6种,它们是整型常量、实型常量、字符型常量、字符串常量、符号常量、逻辑型常量. 引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例 C++11 STL中的容器 123456789101112131415161718192021222324==================================================一、顺序容器：vector：可变大小数组；deque：双端队列；list：双向链表；forward_list：单向链表；array：固定大小数组；string：与vector相似的容器，但专门用于保存字符。==================================================二、关联容器：按关键字有序保存元素：（底层实现为红黑树）map：关联数组；保存关键字-值对；set：关键字即值，即只保存关键字的容器；multimap：关键字可重复的map；multiset：关键字可重复的set；--------------------------------------------------------------------------------无序集合：unordered_map：用哈希函数组织的map；unordered_set：用哈希函数组织的set；unordered_multimap：哈希组织的map；关键字可以重复出现；unordered_multiset：哈希组织的set；关键字可以重复出现。==================================================三、其他项：stack、queue、valarray、bitset 还可以这样定义对象数组 12class Test;Test t[2]=&#123;Test(1,2),Test(3,4)&#125;; 数据结构中data的处理方式:编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问.data是一个柔性数组，可变大小 12345struct Node&#123;int size;char data[0];&#125;; s1和s2是两个结构类型变量，若要使赋值s1=s2合法，则它们必须是同一结构类型的变量 运算符问题C语言中对赋值运算的优先级较低，只比逗号运算符高，且运算顺序是自右向左 以下程序的输出结果是（16）123456main()&#123; int a=0; a+=(a=8); printf(&quot;%d\\n&quot;,a);&#125; a+=(a=8) –&gt; a=a+(a=8) –&gt; a=8+8=16 运算符重载(1)只能使用成员函数重载的运算符有：=、()、[]、-&gt;、new、delete。(2)单目运算符最好重载为成员函数。(3) 对于复合的赋值运算符如+=、-=、*=、/=、&amp;=、!=、~=、%=、&gt;&gt;=、&lt;&lt;=建议重载为成员函数。(4) 对于其它运算符，建议重载为友元函数关于运算符重载 无参函数只能用来定义单目运算符，当前对象作为操作数 单参函数可定义双目运算符，当前对象作为左操作数，形参作为右操作数 定义后置“++”或后置“一一”运算是特例，它们是单目运算符，但需要一个int形参 除了类属关系运算符”.“、成员指针运算符”.*“、作用域运算符”::“、sizeof运算符和三目运算符”?:“以外，C++中的所有运算符都可以重载 const问题 有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员 常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数 const表面含义是个常量，但实际上还是占据一个内存位置的变量，但是它的值一般实在编译时期就决定了 虚函数问题 绝不在构造函数和析构函数中调用virtual函数。 即使不进行强制类型转换，在进行指针赋值运算时，指针变量的基类型也可以不同（X 错） 指针问题 p=NULL 和 p=0 或 p=’\\0’ 等价 static问题对类中的数据成员进行初始化的条件是： 必须是一个（static）静态成员。对于非静态成员不能在类定义中进行初始化。 静态成员的声明中必须是有 const 限定。非 const 的静态成员不能在类定义中进行初始化。 静态成员的类型必须为整型或者是枚举型。其它类型（如浮点型、数组、指针等）不能在类定义中进行初始化。 只能使用一个整型常量表达式（integral constant expression）来进行初始化 待整理 f(2486)的返回值是(7)123456789int f(unsigned int n)&#123; unsigned int m=0; for(m=0;n;++m) &#123; n&amp;=(n-1); &#125; return m;&#125; n&amp;=(n-1)相当于n=n&amp;(n-1),执行一次也就相当于把二进制中的最低位的1置为0；循环执行，也就是计算2468的二进制中有多少个1.2486=2048 + 256 + 128 + 32 + 16 + 4 + 2 七个1 fseek(fp,-20L,2)的含义是将文件指针fp移动到文件末尾倒数第20个字符处volitle问题 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。对于一般变量：为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中。以后再取变量值时，就直接从寄存器中取值。 一个参数既可以是const也可以是volatile：一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"刷题","slug":"开发/刷题","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://charypro.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"Makefile的编写","slug":"开发/Linux/Makefile","date":"2020-03-12T16:00:00.000Z","updated":"2020-03-12T16:00:00.000Z","comments":true,"path":"2020/03/13/开发/Linux/Makefile/","link":"","permalink":"http://charypro.github.io/2020/03/13/%E5%BC%80%E5%8F%91/Linux/Makefile/","excerpt":"Makefile编程","text":"Makefile编程 引用其它的 Makefile1include foo.make *.mk $(bar) 如果文件都没有指定绝对路径或是相对路径的话， make 会在当前目录下首先寻找，如果当前目录下没有找到，那么， make 还会在下面的几个目录下找： 如果 make 执行时，有“-I”或“–include-dir”参数，那么 make 就会在这个参数所指定的目录下去寻找。 如果目录&lt;prefix&gt;/include（一般是： /usr/local/bin 或/usr/include）存在的话， make 也会去找。 想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”. -include &lt;filename&gt; make 的工作方式1、读入所有的 Makefile。2、读入被 include 的其它 Makefile。3、初始化文件中的变量。4、推导隐晦规则，并分析所有规则。5、为所有的目标文件创建依赖关系链。6、根据依赖关系，决定哪些目标要重新生成。7、执行生成命令 文件搜寻如果没有指明这个变量， make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么， make 就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 1VPATH &#x3D; src:..&#x2F;headers 上面的的定义指定两个目录，“src”和“../headers”， make 会按照这个顺序进行搜索。目录由“冒号”分隔。 伪目标“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。 123.PHONY: cleanclean:rm *.o temp","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Linux系统编程","slug":"开发/Linux系统编程","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"linux Shell","slug":"开发/Linux/Shell笔记","date":"2020-03-12T16:00:00.000Z","updated":"2020-03-12T16:00:00.000Z","comments":true,"path":"2020/03/13/开发/Linux/Shell笔记/","link":"","permalink":"http://charypro.github.io/2020/03/13/%E5%BC%80%E5%8F%91/Linux/Shell%E7%AC%94%E8%AE%B0/","excerpt":"linux Shell编程","text":"linux Shell编程 变量的使用123456your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125;readonly variable_name #只读变量unset variable_name #删除变量，不能删除只读变量 变量赋值时不需要加$,使用变量的时候才加美元符$。 字符串1234567891011121314151617your_name=&#x27;runoob&#x27; #单引号，双引号都可以str=&quot;Hello, I know you are \\&quot;$your_name\\&quot;! \\n&quot; #单引号字符串中的变量是无效的，推荐用双引号#Hello, I know you are &quot;runoob&quot;! #获取字符串长度string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4#提取子字符串string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo#查找子字符串#查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 数组1234567891011121314#数组初始化array_name=(value0 value1 value2 value3)#数组赋值array_name[0]=value0#读取数组exho $&#123;array_name[n]&#125;echo $&#123;array_name[@]&#125;#所有数组元素# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; 传递参数 123456echo &quot;执行的文件名：$0&quot;echo &quot;第一个参数为：$1&quot;echo &quot;第二个参数为：$2&quot;echo &quot;第三个参数为：$3&quot; $\\ 与 $@ 区别：*相同点：都是引用所有参数。不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。 运算符算术运算符12345678910111213141516171819202122232425262728#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a 等于 b&quot;fiif [ $a != $b ]then echo &quot;a 不等于 b&quot;fi 关系运算符1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/basha=10b=20if [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot;else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot;else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot;else echo &quot;$a -le $b: a 大于 b&quot;fi printf12printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234 # 郭靖 男 66.12 流程控制语句if…else…fi1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi for1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone while1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done case…in…12345678910case 值 in模式1) command1 ... ;;模式2） command1 ... ;;esac 12breakcontinue 函数12345678910111213141516171819#!/bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73#第一个参数为 1 !#第二个参数为 2 !#第十个参数为 10 !#第十个参数为 34 !#第十一个参数为 73 !#参数总数有 11 个!#作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 另外1read var_name #输入变量值","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Linux系统编程","slug":"开发/Linux系统编程","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"Window上基于QT的FFmpeg环境搭建","slug":"开发/C++/Window上基于QT的FFmpeg环境搭建","date":"2020-02-26T16:00:00.000Z","updated":"2020-02-26T16:00:00.000Z","comments":true,"path":"2020/02/27/开发/C++/Window上基于QT的FFmpeg环境搭建/","link":"","permalink":"http://charypro.github.io/2020/02/27/%E5%BC%80%E5%8F%91/C++/Window%E4%B8%8A%E5%9F%BA%E4%BA%8EQT%E7%9A%84FFmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"Window上基于QT的FFmpeg环境搭建","text":"Window上基于QT的FFmpeg环境搭建 FFmpeg的下载和安装 Windows下载地址，选择电脑对应的32位或64位的Shared和Dev版本进行下载 将下载后的压缩包解压后，把其中bin、include、lib目录提取出来作为此工程的工作环境依赖（库，头文件），创建src目录作为存放源码的路径（即QT的工程） QT工程的搭建（这里只用一个函数做测试）1.在.pro文件里面添加对应头文件和库文件 12INCLUDEPATH += $$PWD/../../includeLIBS += -L$$PWD/../../lib/win32/ -lavcodec 2.在源文件中添加对头文件和库的引用 123456extern &quot;C&quot;&#123; #include &lt;libavcodec/avcodec.h&gt;&#125;//预处理指令导入库#pragma comment(lib,&quot;avcodec.lib&quot;) 3.另外可以修改项目的构建目录，让生成的可执行文件存放在对应目录下面 主程序源码如下： 12345678910111213141516171819#include &lt;QCoreApplication&gt;#include &lt;iostream&gt;using namespace std;//要引用c语言函数extern &quot;C&quot;&#123; #include &lt;libavcodec/avcodec.h&gt;&#125;//预处理指令导入库#pragma comment(lib,&quot;avcodec.lib&quot;)int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); cout &lt;&lt; avcodec_configuration() &lt;&lt; endl; return a.exec();&#125; 接下来的其它程序均可在此基础上添加修改测试","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"QT","slug":"开发/QT","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/QT/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://charypro.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"http://charypro.github.io/tags/qt/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://charypro.github.io/tags/ffmpeg/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"LeetCode刷题记录(简单篇一)","slug":"开发/C++/leetcode刷题记录","date":"2020-01-18T16:00:00.000Z","updated":"2020-06-14T16:00:00.000Z","comments":true,"path":"2020/01/19/开发/C++/leetcode刷题记录/","link":"","permalink":"http://charypro.github.io/2020/01/19/%E5%BC%80%E5%8F%91/C++/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"——持续更新中（15道题）…题目来源：力扣（LeetCode）","text":"——持续更新中（15道题）…题目来源：力扣（LeetCode） 力扣高频算法面试题汇总1.只出现一次的数字“给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 思路：思路一：先排序，然后对 nums[i] 和 nums[i + 1]进行比较，相同则 i+=2 ,继续比较，直到有不相等的(nums[i] != nums[i + 1])，则nums[i]就是出现一次的元素。如果前面的元素都两两相等，则最后剩的那个元素就是出现一次的元素思路二：使用异或的方法(异或满足交换律),出现两次的这些数字经过异或运算后结果一定是0,而任何数字与0进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案 点击查看代码 1234567891011class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int num = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; num ^= nums[i]; &#125; return num; &#125;&#125;; 2. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。示例 1:输入: [3,2,3]输出: 3示例 2:输入: [2,2,1,1,1,2,2]输出: 2 思路1：先采用排序的算法，然后取nums[nums.size()/2]的元素即可思路2：分治法思路3：剔除元素法（推荐方法）：在原序列中去除两个不同的元素后，原序列中的多数元素在新序列中还是多数元素。根据这个原理每次从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0后剔除这两个元素，就是重新从下一个数开始计数，遇到相同的就加1，遇到不同的就减1，总能找到最多的那个 点击查看代码 1234567891011121314151617181920212223class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int max &#x3D; nums[0]; int count &#x3D; 1; if(nums.size() &#x3D;&#x3D; 2) return nums[0]; for(int i &#x3D; 1; i &lt; nums.size(); i++) &#123; if(max &#x3D;&#x3D; nums[i]) &#123; count++; &#125; else &#123; count--; if(count &#x3D;&#x3D; 0) max &#x3D; nums[i+1]; &#125; &#125; return max; &#125;&#125;; 3. 搜索二维矩阵编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。每列的元素从上到下升序排列。示例:现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 思路：仔细观察会发现从右上角到左下角，每一个数的左边都比它小且依次增加，下面都比它大，且依次增加，所以可以跟踪法，从左下角（或者右下角）开始，比它大的往右走（往下走），比它小的往上走（往左走） 点击查看代码 12345678bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int i=matrix.size()-1,j=0; while(i&gt;=0&amp;&amp;j&lt;matrix[0].size()) if(matrix[i][j]==target) return true; else if(matrix[i][j]&gt;target) i--; else j++; return false;&#125; 4. 合并两个有序数组给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 思路1：把两个数组元素放在同一个数组中，无论是新的数组或是放在num1中的后面，最后再来一次排序思路2: 从后面开始用两个值记录数组1和数组2的变化,需要考虑当数组1中只有空位，也就是m=0时，直接把数组2里的值放在数组1即可 点击查看代码 12345678910111213141516class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int temp = 0; int i = m-1, j = n-1, p = m+n-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if(nums1[i] &lt; nums2[j]) nums1[p--] = nums2[j--]; else nums1[p--] = nums1[i--]; &#125; while(j &gt;= 0) nums1[p--] = nums2[j--]; &#125;&#125;; 5. 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。示例 1:输入: “A man, a plan, a canal: Panama”输出: true思路：两个指针指向最左边和最右边，依次往前不断比较。此处注意对字母大小写的判断（(s[m] + 32 - ‘a’) % 32)如果相等则不区分大小写也相等。 点击查看代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isValue(char c) &#123; if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return true; if(c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return true; if(c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return true; return false; &#125; bool isPalindrome(string s) &#123; int m = 0, n = s.length() - 1; while(m &lt; n) &#123; //std::cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; std::endl; if(!isValue(s[m])) m++; else if(!isValue(s[n])) n--; else if((s[m] + 32 - &#x27;a&#x27;) % 32 == (s[n] + 32 - &#x27;a&#x27;) % 32) &#123; m++; n--; &#125; else return false; &#125; return true; &#125;&#125;; 6.分割回文串给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 示例:输入: “aab”输出:[ [“aa”,”b”], [“a”,”a”,”b”]]思路：回溯思想。参考：https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/ 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; if(s.length() == 0) return res; vector&lt;string&gt; temp; backtrack(s, 0, s.length(), temp, res); return res; &#125; void backtrack(const string&amp; s, int is, int len, vector&lt;string&gt;&amp; temp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if(is == len) &#123; res.push_back(temp); return; &#125; for(int i = is; i &lt; len; i++) &#123; if(isPar(s, is, i)) &#123; temp.push_back(s.substr(is, i - is + 1)); backtrack(s, i+1, len, temp, res); temp.pop_back(); &#125; &#125; &#125; bool isPar(string s, int is, int ie) &#123; while(is &lt; ie) &#123; if(s[is] != s[ie]) return false; is++;ie--; &#125; return true; &#125;&#125;; 7.分割单词给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。思路：以str(begin, end)来表示str的子字符串，从前往后遍历，end=1, begin=0;end=2, begin=0/1;end=3, begin=0/1/2;…end=n-1, begin=0/1/…/n-2;一共是(n-1)n/2种，遍历一遍是O(n^2)的时间复杂度。逐次的去判断它们是否与字典中的某个字符串相同，如果相同了，就在end的位置标记相同(true)，end的位置一定在begin之后（begin&lt;end），那么要查询str(begin, end)，begin前面的位置一定要是true才行，意味着已经寻到了一个或者一些匹配字典的子字符串，那么就要记录是否寻得的状态。 点击查看代码 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if(s.empty() || wordDict.size() == 0) return false; int n = s.size(); vector&lt;bool&gt; dp(n+1, false); dp[0] = true; for(int end = 1; end &lt;= n; end++) &#123; for(int begin=0; begin&lt;end; begin++) &#123; if(dp[begin] &amp;&amp; find(wordDict.begin(), wordDict.end(), s.substr(begin, end-begin)) != wordDict.end()) &#123; dp[end] = true; break; &#125; &#125; &#125; return dp[n]; &#125;&#125;; 普通14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1:输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2:输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。 思路：先取前两个字符串找他们的公共前缀pre，然后用pre和接下来一个作比较，找他们的公共前缀，并赋值给pre,就这样不断依次将所有有公共前缀的字符串可以找到。 点击查看代码 12345678910111213141516171819202122232425262728class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int count = strs.size(); if(count == 0) return &quot;&quot;; string pre = strs[0]; for(int i = 1; i &lt; count; i++) &#123; pre = longestCommonPrefix(pre, strs[i]); if(pre.length() == 0) break; &#125; return pre; &#125; string longestCommonPrefix(string s1, string s2) &#123; int len = (s1.size() &gt; s2.size()) ? s1.size() : s2.size(); int i = 0; while(i &lt; len &amp;&amp; s1[i] == s2[i]) &#123; i++; &#125; return s1.substr(0, i); &#125;&#125;; 739. 每日温度请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。思路：单调栈。首先将第一个元素的索引压栈，然后将其它元素与栈顶元素比较，如果比他大，则将栈中元素出栈，并计算该元素索引值与出栈元素索引值的差，并将差放入另一集合中的该位置。如果比它小则入栈。具体可以参考：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/ 点击查看代码 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; ans(T.size()); stack&lt;int&gt; s; for(int i = 0; i &lt; T.size(); i++) &#123; while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123; int previousIndex = s.top(); ans[previousIndex] = i - previousIndex; s.pop(); &#125; s.push(i); &#125; return ans; &#125;&#125;; 1290. 二进制链表转整数给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的 十进制值 。示例：输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5)思路：按照十进制化二进制的方法，一般求二进制的操作（由低位到高位）是二进制数依次乘以$2^{i-1}$次方,但此题输入的二进制数是从高位到低位，若是按照那样的方式首先要得到链表的长度或是反转链表。其实画出十进制转二进制的过程可以发现化到最后商一定是0，所以往前推最后的余数（二进制的高位）$+2*0$ 得到倒数第二位的商,依次递推求和可以得到最后的十进制数 点击查看代码 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode *cur = head; int res = 0; while(cur) &#123; res = res*2 + cur-&gt;val;//此处res*2可换成(res&lt;&lt;1) cur = cur-&gt;next; &#125; return res; &#125;&#125;; 复杂度分析： 时间复杂度：O(N)，其中 N 是链表中的节点个数。 空间复杂度：O(1)。 1266. 访问所有点的最小时间平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。你可以按照下面的规则在平面上移动：每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。必须按照数组中出现的顺序来访问这些点。实例：输入：points = [[1,1],[3,4],[-1,0]]输出：7解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 ,从 [3,4] 到 [-1,0] 需要 4 秒,一共需要 7 秒 这道题就是经典的 切比雪夫距离 问题 123456789101112131415161718192021class Solution &#123;public: int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt; &amp;points) &#123; int a, b; int temp[2]; int count = 0; temp[0] = points[0][0]; temp[1] = points[0][1]; for (int i = 1; i &lt; points.size(); i++) &#123; a = points[i][0]; b = points[i][1]; count += max(abs(a - temp[0]), abs(b - temp[1])); temp[0] = a; temp[1] = b; &#125; return count; &#125;&#125;; 832. 翻转图像给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例：输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 解题思路：如果某行处于对称位置上的数字不相同的话其实是不需要动的，翻转加互换后还是它本身；如果相同的话，就两个位置都分别互换 123456789101112131415161718class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt; &amp;A) &#123; int len = A[0].size(); for (int i = 0; i &lt; A.size(); i++) &#123; for (int j = 0; j &lt; (len + 1) / 2; j++) &#123; if (A[i][j] == A[i][len - j - 1]) A[i][j] = A[i][len - j - 1] = A[i][j] ^ 1; &#125; &#125; return A; &#125;&#125;; 1108. IP 地址无效化给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。 示例 ：输入：address = “1.1.1.1”输出：”1[.]1[.]1[.]1” 123456789string defangIPaddr(string address)&#123; for (int i = address.size(); i &gt; 0; i--) &#123; if (address[i] == &#x27;.&#x27;) address.replace(i, 1, &quot;[.]&quot;); &#125; return address;&#125; 1281. 整数的各位积和之差给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1：输入：n = 234输出：15解释：各位数之积 = 2 * 3 * 4 = 24各位数之和 = 2 + 3 + 4 = 9结果 = 24 - 9 = 15 1234567891011121314class Solution &#123;public: int subtractProductAndSum(int n) &#123; int m = 0, sum = 0, mul = 1; while(n) &#123; m = n % 10; n = n / 10; sum += m; mul *= m; &#125; return mul - sum; &#125;&#125;; LCP1. 猜数字小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。 示例 1：输入：guess = [1,2,3], answer = [1,2,3]输出：3解释：小A 每次都猜对了。 123456class Solution &#123;public: int game(vector&lt;int&gt;&amp; guess, vector&lt;int&gt;&amp; answer) &#123; return (guess[0]==answer[0])+(guess[1]==answer[1])+(guess[2]==answer[2]); &#125;&#125;; 1295. 统计位数为偶数的数字给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 ：输入：nums = [555,901,482,1771]输出：1解释：只有 1771 是位数为偶数的数字。 1234567891011121314class Solution &#123;public: int findNumbers(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (int i : nums) &#123; string s = to_string(i); if(s.length() %2 == 0 ) sum++; &#125; return sum; &#125;&#125;; 771. 宝石与石头给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例:输入: J = “aA”, S = “aAAbbbb”输出: 3 12345678910111213141516171819202122public: int numJewelsInStones(string J, string S) &#123; string a = &quot;[^&quot; + J + &quot;]&quot;; regex pattern(a); string b = regex_replace(S, pattern, &quot;&quot;); return b.length(); &#125;&#125;;//正则表达式class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int num = 0; for (char j : J) &#123; for (char s : S)&#123; if (s == j) num++; &#125; &#125; return num; &#125;&#125;;//一般方法","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"刷题","slug":"开发/刷题","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://charypro.github.io/tags/C/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"面试题收录","slug":"开发/Linux/面试常见问题","date":"2020-01-17T16:00:00.000Z","updated":"2020-01-19T16:00:00.000Z","comments":true,"path":"2020/01/18/开发/Linux/面试常见问题/","link":"","permalink":"http://charypro.github.io/2020/01/18/%E5%BC%80%E5%8F%91/Linux/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"面试题整理收录——软件工程师面试题收录，持续更新中…","text":"面试题整理收录——软件工程师面试题收录，持续更新中… 一、编程1. gdb常用的命令编译的时候加上-g参数表示可以调试 l:查看程序源码，默认10行l 函数名：将显示“函数名”所在函数的源代码r:运行c:继续运行到下一个断点处或者结束n:单步跟踪程序，当遇到函数调用时，也不进入此函数体s:单步调试如果有函数调用，则进入函数until:退出循环体set args 参数:指定运行时的参数show args:查看设置好的参数call 函数(参数):调用程序中的可见程序whatis:查询变量或函数b+函数名:根据函数名设置断点b+行号:根据行号设置断点info break:查看断点列表delete 断点号:删除第几个断点disable 断点号n:暂停第n个断点enable 断点号n:开启第n个断点delete breakpoints:清除所有断点：p 变量:打印变量的值p 函数(参数):调用函数，打印返回值bt:查看堆栈列表quit:退出调试 2. C++ main函数前面是否需要加int或者void类型其实和编译器有关，默认不加是返回int类型的，有的编译器会有警告 对于malloc申请的内存空间，需要进行类型转换，malloc返回的是void *类型，free 后应将其指针赋为NULL,避免产生野指针 #ifndef的最主要目的是防止头文件的重复包含和编译 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？ 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数 C++中struct和class的区别 在C++中，可以用struct和class定义类，都可以继承。区别在于：struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。 C++源文件从文本到可执行文件经历的过程 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 内存分配方式 在C++中，内存分为：栈、堆(malloc)、自由存储区(new)、全局/静态存储区、常量存储区。 p=NULL 的含义 NULL的定义是这样的, #define NULL ((void *)0),应用程序是不能访问0地址的，所以可以用0地址来表示一个空指针。 内联函数的影响 内联函数可能会使代码速度更快，也可能使速度变慢。可能会使可执行文件变大，也可能变小。可能会导致系统性能下降，也可能避免性能下降。内联函数可能（经常是）与速度完全无关 引用和指针的区别 浮点数类型不能直接用等号比较 整型和浮点数类型相乘会自动转化为浮点数 求一个类的大小 空类的大小为 1 类中的成员函数不占用空间 类中的static修饰的成员变量不占空间 类中不管有几个（至少有一个）虚函数，会占用4个字节，因为会创建个虚表，类中首位置存放虚表的指针 继承类的大小就是基类的大小和本类的大小之和，但是如果本类有重写的或是继承的基类的虚函数，则都不会占用新空间，而是会在基类的虚表中覆盖和添加新的位置 二、数据结构1.有一个线程负责产生图像数据，有另外两个线程都需要使用这些数据，如何设计这样的数据结构？此题中产生数据的线程可以成为生产者，而另外两个线程可以称为消费者，这就是典型的生产者消费者模型，为了保证数据的完整和功能的可靠，就需要对图像数据这块资源区进行保护，通常的做法是对其加锁，在写数据的时候不能读，但为了保证效率可以采用类似队列的数据结构，只要保证存在一帧完整的数据就可以被其他两个线程使用。 三、操作系统1.死锁是什么？死锁的原因有哪些？死锁的四个必要条件是什么？ 如何解开死锁？ 死锁是指是指两个或两个以上的进程（线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，比如进程A需要获取进程B的锁，但进程B首先要得到进程A的锁才能释放自己的锁，但进程A还在阻塞在那里，无法释放它的锁，所以就陷入了僵局 产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程（线程）使用。 （2） 请求与保持条件：一个进程（线程）因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件 : 此进程（线程）已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件 : 多个进程（线程）之间形成一种头尾相接的循环等待资源关系。 如何避免死锁： （1）对于互斥，因为互斥不能破坏，所以不能由互斥入手来避免死锁 （2）对于请求与保持，请求的时候先把自己的锁释放掉，然后再申请新的锁 （3）对于循环等待，是一样的，在申请新锁的时候，先把自己的锁释放，在申请新锁，就不会陷入循环等待中 （4）对于不剥夺，如果别人的锁的优先级比自己的锁的优先级高，则可以抢过来 2.进程与线程的区别银行家算法 2.计算下列程序一共有多少条进程?12345678int main()&#123; fork(); fork() &amp;&amp; fork() || fork(); fork(); return 0;&#125; 子进程有10个，父进程有10个 共20个(题源：https://blog.csdn.net/nan_lei/article/details/83867694) 计算机网络 OSI七层模型？TCP的四层模型？OSI七层模型：从上层网下层依次是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层TCP四层模型：从上层网下层依次是应用层、传输层、网络层、数据链路和网络接口层 TCP、UDP的区别？共同点：同为传输层协议不同点： TCP：有连接(通信前要进行三次握手)，可靠（保证四无原则：数据无误 无丢失 无失序 无重复到达）适合于对传输质量要求较高，以及传输大量数据的通信。用户登录账户管理 UDP：无连接，不保证可靠高效率的数据传输（实时性） 发送小尺寸数据 广播/组播 通讯软件的点对点文本通讯以及音视频通讯通常采用UDP协议 待解答 vector 或 map 的内部实现，各种操作的复杂度以及迭代器失效的可能场景vector的数据安排以及操作方式，与array非常类似，两者唯一的区别是空间运用的灵活性，array是静态空间，一旦配置了就不能改变，如果你想要大一点的空间，就必须首先配置一块新空间，然后将原来的元素一一复制进来，再把原来的空间释放给系统。但是vector是动态空间，随着元素的增加，它的内部机制会自行扩充空间以容纳新元素，因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，vector动态增加大小时，并不是在原空间之后持续新空间而是以原大小的两倍另外配置一块较大的空间，然后将内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间，因此，一旦引起空间重新配置，指向原vector的所有迭代器都失效了。map:Map是关联容器，以键值对的形式进行存储，方便进行查找，关键词起到索引的作用，值则表示与索引相关联的数据，以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成 shared_ptr 的线程安全性、循环引用的后果及如何避免、weak_ptr 的作用C++的特性：封装继承和多态纯虚函数 内存对齐的原则 什么情况下需要将析构函数定义为虚函数？ 当基类指针指向派生类的对象（多态性）时。如果定义为虚函数，则就会先调用该指针指向的派生类析构函数，然后派生类的析构函数再又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。 C++中类与结构体的区别？(1)最本质的一个区别就是默认的访问控制： struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。(2)“class”这个关键字还用于定义模板参数 指针数组和数组指针，常量指针和指针常量，指针函数和函数指针； a[10] : 指针数组(a)[10] : 数组指针int *fun() : 指针函数int (p)(int, int) : 函数指针const char *a; 内容不可变，常量指针char const a; 地址不可变，指针常量8. i++是否为原子操作？在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。而i++是分三个阶段的，都可能被打断 常用的设计模式单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点；定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式关于图像格式 YUV 4:4:4采样，每一个Y对应一组UV分量，图像和rgb占用的字小大小一致，均为pixelsize*3。YUV 4:2:2采样，每两个Y共用一组UV分量，占用的大小为pixelsize+pixelsize/2+pixelsize/2。YUV 4:2:0采样，每四个Y共用一组UV分量，占用大小为pixelsize+pixelsize/4+pixelsize/4 packed:打包格式是将yuv分量混合存在同一个数组中，yuv的存储先后不同，细分为了yuv、yvu、yvyu、uyvy等等planar：平面格式是将yuv三个分量存成三个数组或者两个数组分别存储 常见的YUV格式列表：I420: YYYYYYYY UU VV =&gt;YUV420PYV12: YYYYYYYY VV UU =&gt;YUV420PNV12: YYYYYYYY UVUV =&gt;YUV420SPNV21: YYYYYYYY VUVU =&gt;YUV420SP QT信号槽的用法 一个信号可以和多个槽相连：这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的 多个信号可以连接到一个槽：只要任意一个信号发出，这个槽就会被调用 一个信号可以连接到另外的一个信号 槽可以被取消链接：对象被删除的时候 自定义信号槽需要注意的事项 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码； 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用QObject::connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 Q_OBJECT的作用 如果不加这一句代码，信号和槽函数的连接总是不成功 3.19 面试 QThread如何使用，线程的同步 QT串口编程使用的步骤 QT中的QSS QT中的定时器使用 一个链表删除其中一个节点如何做 链表和数组的区别 指针与引用的区别 有类似二级指针一样的二级引用吗？ const与define的区别 为什么析构函数声明为虚函数 判断一个8位数的第四位为1 判断一个无符号数是否是奇数，不用%2 根据数据名求其元素个数 设计模式了解多少","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Linux系统编程","slug":"开发/Linux系统编程","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://charypro.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"顺序容器","slug":"开发/C++/C++","date":"2020-01-15T16:00:00.000Z","updated":"2020-01-20T16:00:00.000Z","comments":true,"path":"2020/01/16/开发/C++/C++/","link":"","permalink":"http://charypro.github.io/2020/01/16/%E5%BC%80%E5%8F%91/C++/C++/","excerpt":"C++中的顺序容器操作","text":"C++中的顺序容器操作 顺序容器操作顺序容器的类型 vector: 一般选用这个 deque: 双端队列 list: 双向链表 forward_list: 单向链表 array: 固定数组大小，不支持改变容器大小 string: 与 vector 相似，专门保存字符 容器定义和初始化1234567891011C c;//c1初始化为c2的拷贝C c1(c2);C c1 = c2;//使用值进行初始化C c&#123;a, b, c...&#125;;C c = &#123;a, b, c...&#125;;C c(b, e);//使用迭代器b-&gt;e范围元素初始化(类型必须兼容)//顺序容器C seq(n);//包含n个元素，这n个元素进行了值初始化Cseq(n, t);//n个t进行初始化 容器赋值12345678c1 = c2;c = &#123;a, b, c...&#125;;swap(c1, c2);c1.swap(c2);//assign操作不适用于array和关联容器seq.assign(b, e);//迭代器b-&gt;eseq.assign(i1);//使用i1列表初始化seqseq.assign(n, t);//n个t 容器元素的插入 forward_list不支持push_back和emplace_back vector和string不支持push_front和emplace_front emplace_front、emplace和emplace_back这些操作是构造而不是拷贝元素，对应的是push_front、insert和push_back这些操作是拷贝元素到容器中而不是构造。1234//以下两种是将对象放入容器c.emplace_back(&quot;223.23&quot;, 23, 45.6);//使用三个参数的Sales_data构造函数c.push_back(Sales_data(&quot;223.23&quot;, 23, 45.6));//创建一个Sales_data对象放入cc.insert(iter, &quot;word&quot;);//将“word”插入到iter所指元素的之前位置，返回的是迭代器指向的这个新元素，emplace也是同理 容器元素的访问 at和下表操作只适用于string、vector、deque和array back不适用于forward_list。 使用迭代器注意：end指向容器尾元素之后的元素(不存在)，为了获取尾元素，需要将递减该迭代器 在访问容器中的元素中容易出现访问越界的情况，应注意避免 1234c.back();//返回c的尾元素c.front();//返回c的首元素的引用c[n];//返回c中下标为n的元素的引用c.at(n);//返回c中下标为n的元素的引用 容器中元素的删除以下操作不适用于array, forward_list不支持pop_back;vector和string不支持pop_front。12345c.pop_back();//删除c的尾部元素c.pop_front();//删除c的首部元素c.erase(p);//删除迭代器p所指定的元素c.erase(b, e);//删除迭代器b和e所指定的范围c.clear();//删除c中所有的元素 迭代器失效情况向迭代器中添加元素和删除元素的代码可能会使迭代器失效，所以需要保证每次改变容器的大小之后重新定位迭代器，尤其是vector、string和deque 在循环中使用迭代器需要考虑迭代器失效的情况，需要保证在每一次循环都要更新迭代器、引用或指针 end返回的迭代器不要保存，当容器中有发生元素增删都会使保存的迭代器失效，需要在插入或删除之后重新调用end()，不能再循环前保存 容器的容量 shrink_to_fit只适用于vector、string和deque capacity和reserve只适用于vector和string reserve不会改变容器中元素的个数，仅影响vector预先分配的内存空间大小，只有当需要的内存空间超过当前容量时，reserve函数才会被调用 size()是当前容器中元素的数量123c.shrink_to_fit();//将capacity()减小为与size()相同大小c.capacity();//不重新分配内存的话，c可以保存多少元素c.reserve();//分配至少能容纳n个元素的内存空间 string的额外操作 构造string的其他方法1234string s(cp, n);//cp指向的数组的前n个字符的拷贝string s(s2, pos2);//从s2的下标pos2位置开始数据的拷贝string s(s2, pos2, len);//长度位lens.substr(p1, p2);//字串，从下标p1位置到p2位置 其它操作12345678910111213141516171819202122232425//插入删除s.insert(pos, args);//在pos之前插入args，pos可以是下标也可以是迭代器s.erase(pos, len);//pos位置删除长度位len的字符s.assign(args);//将s中的字符替换为args指定的字符s.append(args);//将args追加到ss.replace(range, args);//替换range范围内的字符为args指定的字符//查找s.find(args);//查找args第一次出现的地方s.sfind(args);//查找args最后一次出现的地方s.find_first_of(args);//查找args中任何一个字符第一次出现的地方s.find_last_of(args);//查找args中任何一个字符最后一次出现的地方s.find_first_not_of(args);//查找s中第一个不在args中的字符s.find_last_not_of(args);//查找s中最后一个不在args中的字符//比较函数s.compare();//参数可以有地址，长度和其它字符串，和strcmp很类似，返回值也一样//数值转化to_string(val);//将val转换为string类型stoi();//intstol();//longstoul();//unsigned longstoll();//long longstoull();//unsigned long longstof();//floatstod();//doublestold();//unsigned double","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"标准库","slug":"开发/标准库","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://charypro.github.io/tags/c/"}],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}},{"title":"Linux进程间通信","slug":"开发/Linux/进程间通信","date":"2020-01-15T16:00:00.000Z","updated":"2020-01-17T16:00:00.000Z","comments":true,"path":"2020/01/16/开发/Linux/进程间通信/","link":"","permalink":"http://charypro.github.io/2020/01/16/%E5%BC%80%E5%8F%91/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程的操作在 Linux 中最主要的进程标识有进程号(PID)和它的父进程号(PPID)，其中 PID 惟一地标识一个进程。在 Linux 中获得当前进程的 PID 和 PPID 的系统调用函数为 getpid() 和 getppid() 进程根据它的生命周期可以分为三种状态: 执行态：该进程正在运行，正在占用 CPU。 就绪态：进程已经具备执行的一切条件，正在等待分配 CPU 的处理时间片。 等待态：进程不能使用 CPU，若等待事件发生（等待的资源分配到）则可将其唤醒。 转换关系如下图: Linux 中的进程包含 3 个段，分别为“数据段”、“代码段”和“堆栈段”。 数据段：存放的是全局变量、常量以及动态分配的空间。又分为普通数据段、静态初始化的全局变量、BSS 数据段（存放未初始化的全局变量）和堆（存放动态分配的数据） 代码段：存放的是程序代码的数据 堆栈段：存放的是子程序的返回地址、子程序的参数以及程序的局部变量 进程结构示意图如下： 在 Linux 系统中，进程的执行模式划分为用户模式和内核模式。如果当前运行的是用户程序、应用程序或者内核之外的系统程序，那么对应进程就在用户模式下运行；如果在用户程序执行过程中出现系统调用或者发生中断事件，那么就要运行操作系统（即核心）程序，进程模式就变成内核模式。在内核模式下运行的进程可以执行机器的特权指令，而且此时该进程的运行不受用户的干扰，即使是 root 用户也不能干扰内核模式下进程的运。 进程间通信进程间通信分为UNIX进程间通信（管道、信号），System V进程间通信（消息队列，信号量，共享内存），Posix 进程间通信（Posix 消息队列、 Posix 信号量以及 Posix 共享内存） 管道无名管道：可用在具有亲缘关系进程间的通信,在使用过程中需要将父进程的写端fd[1]和子进程的读端 fd[0] 关闭。 有名管道：除具有无名管道所具有的功能外还允许无亲缘关系进程间的通信。 12345678910111213int pipe(int pipefd[2]);/*功能：创建一个无名管道参数：操作管道的文件描述符，fd[0]表示读端，fd[1]表示写端。返回值：成功返回0，失败返回-1.*/int mkfifo(const char *pathname, mode_t mode);/*功能：创建一个有名管道参数：pathname：有名管道的路径名 mode：权限，八进制数表示返回值：成功返回0，失败返回-1*/ 信号在软件层次上对中断机制的一种模拟，用于通知进程有某事件发生. 常用的API: 123456789101112131415161718192021222324252627282930313233343536373839int kill(pid_t pid, int sig);/*功能：发送一个信号参数：pid：发送的目标进程 sig：发送的信号名称返回值：成功返回0，失败返回-1；*/int raise(int sig);/*功能：向调用进程发送一个信号参数：sig:信号的种类返回值：成功返回0，失败返回非0*/unsigned alarm(unsigned seconds);/*功能：定时发送SIGALRM信号参数：定时的秒数返回值：如果首次调用alarm，那么返回0；否则返回上一个alarm函数所剩余的时间。*/int pause(void)/*功能：将进程挂起接收任意一个信号；参数：无返回值：捕捉到信号或者信号处理函数返回时，返回-1；*/void (*signal(int signum, void (*handler)(int)))(int));/*功能：自定义对信号的处理参数： signum：需要设定信号的名字 SIG_IGN 为忽略该信号 SIG_DFL 采用默认方式处理信号 handler：一个函数指针，指向一个返回值为void，参数为int型的这么一个函数；返回值：返回handler函数的地址*/ 实验例程消息队列消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列可以按照类型来发送/接收消息。 消息队列操作的过程：获得key值，创建或打开一个消息队列，向消息队列中发送/接受消息，对消息队列进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344int msgget(key_t key, int msgflg);/*功能：创建或打开一个消息队列参数：key：ftok返回值或者是IPC_PRIVATE msgflg：八进制权限返回值：成功返回msgid，失败返回-1 */int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);/*功能：向消息队列中发送消息参数：msgid：消息队列的ID msgp：存放消息的结构体指针 msgsz：消息正文的大小 msgflg：设为0则直到发送完成函数才返回，IPC_NOWAIT 消息没有发送完成函数也会立即返回。返回值：成功返回0，失败返回-1*/ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);/*功能：从消息队列中读取指定类型的消息参数：msgid：消息队列的ID msgp：存放消息的结构体指针 msgsz：消息正文的大小 msgtyp：消息的类型 msgflg：0：若无消息函数会一直阻塞，IPC_NOWAIT：若没有消息，进程会立即返回ENOMSG。返回值：成功返回读取到的消息长度，失败返回-1 struct msgbuf &#123; long mtype; // message type, must be &gt; 0 char mtext[1]; // message data &#125;;*/ int msgctl ( int msgqid, int cmd, struct msqid_ds *buf ); /*功能：对消息队列进行操作参数：msgqid：消息队列的ID cmd： IPC_STAT表示获取消息队列的信息 IPC_SET表示设置消息队列的信息 IPC_RMID表示删除消息队列 buf ：消息队列缓冲区返回值：成功返回0，失败返回-1*/ 实验例程共享内存共享内存是一种最为高效的进程间通信方式。因为进程可以直接读写内存，不需要任何数据的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进程将其映射到自己的私有地址空间。需要锁或者信号量来做同步。 使用共享内存顺序：获取key值,创建或打开一段共享内存，映射/撤销映射共享内存，对共享内存进行操作 123456789101112131415161718192021222324252627282930313233343536373839404142key_t ftok(const char *pathname, int proj_id);/*功能：指定一文件，获得一个key值参数：pathname：文件名 proj_id：密码八位，通常用一个字符表示，一个字符八位返回值：成功返回一个key值，失败返回-1；*/int shmget(key_t key, size_t size, int shmflg);/*功能：创建或打开一段共享内存参数：key：ftok函数返回值或者IPC_PRIVATE，如果是private，每个申请共享内存的进程都会获得一块共享内存，而不会因为存在而不会创建 size：申请共享内存的大小 shmflg：打开方式及权限 IPC_CREAT IPC_EXCL返回值：成功返回创建的共享内存的shmid，失败返回-1并且设置errno,一般需要对其返回值判断*/void *shmat(int shmid, const void *shmaddr, int shmflg);/*功能：映射共享内存参数：shmid：共享内存ID shmaddr：一般设为NULL，否则需要自定义映射地址 shmflg：SHM_RDONLY为只读，0表示可读可写返回值：成功返回映射后的地址，失败返回-1*/int shmdt(const void *shmaddr);/*功能：取消映射共享内存参数：取消映射的地址返回值：成功返回0，失败返回-1；*/int shmctl(int shmid, int cmd, struct shmid_ds *buf);/*功能：对共享内存进行操作参数：shmid：共享内存的ID cmd：IPC_STAT表示获取共享内存的信息 IPC_SET表示设置共享内存的信息 IPC_RMID表示删除共享内存返回值：成功返回0，失败返回-1*/ 实验例程：1 信号量信号量是用来解决进程之间的同步与互斥问题的一种进程之间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（PV 操作）。其中信号量对应于某一种资源，取一个非负的整型值。信号量值指的是当前可用的该资源的数量，若它等于 0 则意味着目前没有可用的资源。P操作：（信号量值减一）如果有可用的资源（信号量值&gt;0），则占用一个资源，进入临界区V 操作：（给信号量值加一）如果在该信号量的等待队列中有进程在等待资源，则可以唤醒一个阻塞进程。如果没有进程等待它，则释放一个资源。 在 Linux 系统中，使用信号量通常分为以下几个步骤：（1）创建信号量或获得在系统已存在的信号量，此时需要调用 semget()函数。不同进程通过使用同一个信号量键值来获得同一个信号量。（2）初始化信号量，此时使用 semctl()函数的 SETVAL 操作。当使用二维信号量时，通常将信号量初始化为 1。（3）进行信号量的 PV 操作，此时调用 semop()函数。这一步是实现进程之间的同步和互斥的核心工作部分。（4）如果不需要信号量，则从系统中删除它，此时使用 semclt()函数的 IPC_RMID 操作。此时需要注意，在程序中不应该出现对已经被删除的信号量的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int semget(key_t key, int nsems, int semflg);/*参数： key, ftok()返回值 nsems, 指定的信号量集合中的信号量个数 semflg, IPC_CREAT IPC_EXCL返回值：返回该集合的标识符，失败-7， 1.*/int semctl(int semid, int semnum, int cmd, ...);/*功能：信号量集合的控制参数： semid, 指定要操作的集合 semnum, 要操作的信号量的编号，编号从0开始 cmd： GETVAL：获取信号灯的值, 返回值是获得值。 比如：value = semctl(semid, 0, GETVAL)； SETVAL：设置信号灯的值，需要用到第四个参数。*/ 第四个参数类型如下： union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */ &#125;; 比如： union semun&#123; int val; &#125;; union semun mysenum; mysemum.val = 10; semctl(semid, 0, SETVAL,mysemnum); IPC_RMID：从系统中删除信号灯集合 比如： semctl(semid, 0, IPC_RMID); 返回值：和cmd有关，失败-1.int semop ( int semid, struct sembuf *opsptr, unsigned nops);功能：就是对信号量集合中的信号量进行PV操作参数： semid, opsptr, struct sembuf&#123; unsigned short sem_num; /* semaphore number */ short sem_op; /* semaphore operation */ short sem_flg; /* operation flags */ &#125;; 成员分析： sem_num 表示要操作的信号量的编号 sem_op, 表示进行P或者V操作， 比如：sem_op = 10(+10) sem_op = -10(-10) sem_op = 0, 那么semop函数会等到该信号量的值变为0为止。 sem_flg, 0(最常用的)，表示semop函数的操作是阻塞的，直到成功为止。 IPC_NOWAIT，表示semop函数的操作是非阻塞的，如果操作没有成功，立刻返回。 SEM_UNDO（不常用），设置只对当前进程有效，不会保存到系统的信号量集合中。 nops, 调用一次semop要操作的信号量的个数 返回值：成功0， 失败-1 程序如下：实现功能，运行一次一个信号量进行+5操作，另一个信号量-5操作，等到信号量减为0时，阻塞 套接字可用于网络中不同机器之间的进程间通信，具体内容会在socket网络编程说明 各种进程间通信方式的对比如图所示：","categories":[{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Linux系统编程","slug":"开发/Linux系统编程","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[],"author":{"name":"Chary","avatar":"/assets/logo/xiaote_logo.jpeg"}}],"categories":[{"name":"Blog搭建","slug":"Blog搭建","permalink":"http://charypro.github.io/categories/Blog%E6%90%AD%E5%BB%BA/"},{"name":"开发","slug":"开发","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"开发/算法","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E7%AE%97%E6%B3%95/"},{"name":"QT","slug":"开发/QT","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/QT/"},{"name":"刷题","slug":"开发/刷题","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E5%88%B7%E9%A2%98/"},{"name":"Linux系统编程","slug":"开发/Linux系统编程","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"标准库","slug":"开发/标准库","permalink":"http://charypro.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://charypro.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://charypro.github.io/tags/QT/"},{"name":"面试","slug":"面试","permalink":"http://charypro.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"c++","slug":"c","permalink":"http://charypro.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"http://charypro.github.io/tags/qt/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://charypro.github.io/tags/ffmpeg/"}]}